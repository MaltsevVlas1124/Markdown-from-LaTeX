*Ця задача повністю включає в&nbsp;себе попередню задачу «Дерева (вставка, пошук)».
Тому, в&nbsp;разі виникнення проблем із&nbsp;розв'язуванням цієї задачі, рекомендується спочатку зробити попередню, а&nbsp;також прочитати примітку наприкінці умови цієї задачі.*

Напишіть програму, яка реалізовуватиме у&nbsp;бінарному дереві пошуку дії «вставити» та&nbsp;«знайти» (за&nbsp;значенням). Програма повинна виконувати послідовність запитів ви́гляду `ADD` *n*, `SEARCH` *n*, `DELETE` *n* та&nbsp;`PRINTTREE`, де&nbsp;*n* — натуральне число́.

Для кожного запиту `ADD` *n* слід виконати такі дії: якщо&nbsp;вказаного числа́ ще&nbsp;нема в&nbsp;дереві, вставити у&nbsp;дерево і&nbsp;виво́дити на&nbsp;екран слово `DONE`, якщо&nbsp;вже є — залишати дерево як&nbsp;було (не&nbsp;вставляти додаткову копію) і&nbsp;виво́дити на&nbsp;екран слово `ALREADY`.

Для кожного запиту `SEARCH` *n* слід вивести на&nbsp;екран слово `YES` (якщо&nbsp;значення знайдене у&nbsp;дереві) або слово `NO` (якщо&nbsp;не&nbsp;знайдене); при виконанні запитів `SEARCH` дерево не&nbsp;змінюється.

Для кожного запиту `DELETE` *n* слід виконати такі дії: якщо&nbsp;вказаного числа́ є в&nbsp;дереві, вилучити його з&nbsp;дерева і&nbsp;виводити на&nbsp;екран слово `DONE`, якщо&nbsp;нема — залишати дерево як&nbsp;було і&nbsp;виво́дити на&nbsp;екран слово `CANNOT`. При видаленні елемента, що&nbsp;має обох синів, обов’язково обмінювати значення з&nbsp;максимальним елементом лівого піддерева.

Для кожного запиту `PRINTTREE` слід вивести на&nbsp;екран усе дерево, обов’язково дотримуючись того ж формату, що&nbsp;й&nbsp;наведений далі алгоритм.

## Вхідні дані
В&nbsp;кожному рядку вхідних даних записаний один із&nbsp;запитів `ADD` *n*, або `SEARCH` *n*, або `DELETE` *n*, або `PRINTTREE` (без лапок; сло́ва записані великими латинськими буквами; для запитів `ADD`, `SEARCH` та&nbsp;`DELETE` число відділене від слова одинарним пробілом і&nbsp;перебуває в&nbsp;межах від 1&nbsp;до&nbsp;1234567890). Гарантується, що&nbsp;запити `PRINTTREE` будуть лише у&nbsp;моменти, коли дерево не&nbsp;порожнє. Загальна кількість запитів не&nbsp;перевищує 1000&nbsp;запитів, з&nbsp;них не&nbsp;більше 20&nbsp;запитів `PRINTTREE`.

## Вихідні дані
Для кожного запиту виво́дити відповідь на&nbsp;нього. Для запитів `ADD` та&nbsp;`SEARCH` — відповідне слово в&nbsp;окремому рядку (великими латинськими буквами, без лапок). На&nbsp;запит `PRINTTREE` треба виводити дерево, обов’язково відповідно до&nbsp;такого алгоритму:

```csharp
public void PrintTree(Node root, int level)
{
    if (root == null)
        return;
    PrintTree(root.left, level + 1);
    Console.WriteLine(new String('.', level) + root.Data);
    PrintTree(root.right, level + 1);
}
```

(Початковий виклик цього методу — `PrintTree(root, 0)`. Якщо описати цей алгоритм словами, вийде приблизно так: слід виво́дити спочатку ліве піддерево, потім корінь, потім праве піддерево, і&nbsp;результат виходить впорядкованим згори донизу так, як&nbsp;при класичному зображенні мав би бути впорядкований зліва направо; перед кожним елементом треба виво́дити стільки крапочок, який це&nbsp;ярус, вважаючи, що&nbsp;корінь є єдиним елементом ярусу 0 (слід взагалі не&nbsp;ставити крапочок), сини кореня є елементами ярусу 1 (слід поставити рівно одну крапочку), «онуки» (сини синів) кореня є елементами ярусу 2 (слід поставити рівно дві крапочки), і&nbsp;так далі.)

## Приклади

**Вхідні дані:**
```
ADD 2
ADD 7
ADD 5
PRINTTREE
ADD 5
DELETE 3
ADD 1
PRINTTREE
DELETE 7
PRINTTREE
```

**Вихідні дані:**
```
DONE
DONE
DONE
2
..5
.7
ALREADY
CANNOT
DONE
.1
2
..5
.7
DONE
.1
2
.5
```

## Примітка
1.  Враховувати вищезгадану фразу «При видаленні елемента, що&nbsp;має обох синів, обов’язково обмінювати значення з&nbsp;максимальним елементом лівого піддерева.», на&nbsp;жаль, абсолютно необхідно для зарахування розв'язку. Попри те, що&nbsp;це&nbsp;взагалі-то не&nbsp;є об'єктивно необхідним для непротирічивості дерева (цей спосіб правильний, але є й&nbsp;інші правильні способи). Однак, у&nbsp;цій задачі все-таки необхідно застосувати саме конкретно цей спосіб, бо&nbsp;конкретно в&nbsp;ній визначення правильності Вашої програми робиться просто порівнянням її відповіді зі зразком (без глибшого аналізу смислу), і&nbsp;це&nbsp;переписуватися не&nbsp;буде. Кому це&nbsp;не&nbsp;подобається — може просто не&nbsp;робити цю задачу.
2.  Одна з&nbsp;відносно частих помилок при виконанні цієї задачі — написаний студентом код помилково виво́дить два повідомлення `YES` замість одного при успішному видаленні елемента, що&nbsp;має обох синів. Переконайтеся, що&nbsp;у&nbsp;Вашого коду нема конкретно цієї проблеми.
