На площині задані координати ~n~ (~4 \le n \le 15~) різних вершин.

Знайти найкоротший замкнутий маршрут, що&nbsp;починається і&nbsp;закінчується в&nbsp;1-й вершині і&nbsp;відвідує всі інші вершини по&nbsp;одному разу. Дозволяється (якщо так виявляється вигідно) проїжджати через вершину, не&nbsp;зупиняючись (див. приклад 1).

Довжина маршруту обчислюється як&nbsp;сума довжин складових його ребер, довжини окремих ребер обчислюються згідно звичайної евклідової метрики, як&nbsp;~\sqrt{(x_A-x_B)^2+(y_A-y_B)^2}~.

## Вхідні дані
Перший рядок містить кількість вершин ~n~ (~4 \le n \le 15~). Кожен з&nbsp;наступних ~n~ рядків містить по&nbsp;два розділених пропуском числа з&nbsp;плаваючою точкою — ~x~- та&nbsp;~y~-координати відповідної вершини.

## Вихідні дані
Перший рядок повинен містити єдине число (з&nbsp;плаваючою крапкою) — знайдену мінімальну довжину замкнутого маршруту. Другий рядок повинен містити перестановку чисел 2, 3, ..., ~n~ — порядок, в&nbsp;якому треба відвідувати ці вершини. Ч́исла всередині другого рядка повинні розділятися одинарними пропусками.

## Приклади
**Вхідні дані:**
```
4
0 0
2 0.2
7 0.7
5 0.5
```

**Вихідні дані:**
```
1.40698258695692E+0001
2 4 3
```

**Вхідні дані:**
```
5
1 0
4 4
3 2
4 0
1 1
```

**Вихідні дані:**
```
1.24721359549995E+0001
5 3 2 4
```

## Примітка
Задача з&nbsp;такими обмеженнями, по&nbsp;ідеї, повинна вирішуватися хоч методом гілок і&nbsp;меж, хоч динамічним програмуванням по&nbsp;підмножинам. Але вона, по&nbsp;ідеї, не&nbsp;повинна вирішуватися самими лише відтинаннями пошуку з&nbsp;поверненням (backtracking), що&nbsp;не&nbsp;намагається оцінювати можливий діапазон довжин́и ще не&nbsp;побудованої частини шляху.
