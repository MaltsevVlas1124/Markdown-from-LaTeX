Напишіть програму, яка реалізовуватиме пошук у&nbsp;ширину в&nbsp;простому гра́фі, вершини якого не&nbsp;нумеровані й&nbsp;ідентифікуються словесними назвами.

## Вхідні дані
В&nbsp;першому рядку вхідних даних задано число́ *NUM* — кількість різних пошуків у&nbsp;ширину, які треба виконати (на&nbsp;різних гра́фах). Далі йдуть *NUM* блоків, кожен з&nbsp;яких має таку структуру.

Перший рядок блоку містить єдине ціле число́ *M* — кількість ре́бер гра́фа. Далі йдуть *M* рядків, кожен з&nbsp;яких містить по&nbsp;дві назви (назви гарантовано не&nbsp;містять пробілів і&nbsp;відділені одна від&nbsp;одної одним пробілом) — кінці відповідного ребра́. Далі, в&nbsp;останньому рядку блоку, записана єдина назва — вершина, починаючи з&nbsp;якої треба запустити по́шук (ця назва гарантовано хоча б&nbsp;раз згадувалася як&nbsp;кінець одного з&nbsp;ре́бер).

## Вихідні дані
Виведіть на&nbsp;стандартний вихід (екран) *NUM* блоків, у&nbsp;кожному з&nbsp;яких записані відстані від вказаної початкової вершини до&nbsp;всіх досяжних (якщо є недосяжні вершини, вони взагалі не&nbsp;згадуються). Перелік має бути відсортований по&nbsp;назвам вершин, кожна пара (назва, відстань) має виводитися в&nbsp;окремому рядку, блоки мають бути відділені один від&nbsp;одного рядком `===` (три знаки дорівнює).

## Приклади

**Вхідні дані:**
```
2
2
Cherk Zol
Cherk Sm
Zol
4
A Bb
Bb Ccc
Ccc A
Dddd Eeeee
Bb
```

**Вихідні дані:**
```
Cherk 1
Sm 2
Zol 0
===
A 1
Bb 0
Ccc 1
```

## Примітка
Задачу можна розв’язати, наприклад, будь-яким з&nbsp;таких двох способів (можливі й&nbsp;інші, це&nbsp;лише приклади правильних):
*   Граф подавати так само, як&nbsp;у&nbsp;«Пошуку в&nbsp;ширину—1», а&nbsp;для перетворень назв у&nbsp;номери та&nbsp;номерів у&nbsp;назви користуватися `SortedDictionary< string, int >` та&nbsp;`List<string>` відповідно. Для виведення у&nbsp;відсортованому порядку використати той самий `SortedDictionary< string, int >`, що&nbsp;перетворює назви у&nbsp;номери.
*   Увесь час працювати безпосередньо з&nbsp;рядковими назвами, подаючи граф, наприклад, як&nbsp;`Dictionary< string, List<string> >`. Відповідно замінюються й&nbsp;решта структур даних. Зокрема, масив відстаней перетворюється у,&nbsp;наприклад, `SortedDictionary< string, int >`, який міститиме по&nbsp;суті готову відповідь конкретного по́шуку.
