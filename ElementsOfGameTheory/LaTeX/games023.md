Кількакрокова послідовна гра&nbsp;на&nbsp;дереві рішень відбувається так:
спочатку 1-й&nbsp;гравець повинен прийняти рішення, вибравши один&nbsp;з&nbsp;можливих варіантів свого ходу;
деякі&nbsp;з&nbsp;цих варіантів ходу можуть від&nbsp;того мати числові значення, скільки від&nbsp;того виграв 1-й&nbsp;гравець і&nbsp;скільки 2-й,
решта передбачають, що&nbsp;тепер повинен прийняти рішення (вибрати варіант свого ходу) 2-й&nbsp;гравець,
вже знаючи, яке рішення перед&nbsp;тим прийняв (який варіант свого ходу вибрав) 1-й&nbsp;гравець.
Серед варіантів ходу 2-го гравця теж деякі можуть мати готові числові значення, скільки від&nbsp;того виграв 1-й&nbsp;гравець і&nbsp;скільки 2-й,
а&nbsp;решта передбачати, що&nbsp;тепер повинен прийняти рішення (вибрати варіант свого ходу) знову 1-й&nbsp;гравець.
І&nbsp;так далі.

(Цю схему можна узагальнити&nbsp;на&nbsp;більшу кількість гравців, але&nbsp;в&nbsp;цій задачі гравців рівно двоє, й&nbsp;рішення приймають спочатку 1-й, потім 2-й, потім 1-й, потім 2-й, ...)

Всі гілки такого *дерева* мусять колись закінчитися «листками» з&nbsp;готовими числовими значеннями, скільки виграв 1-й&nbsp;гравець і&nbsp;скільки 2-й, але&nbsp;шляхи від&nbsp;кореня (початкового вибору 1-го гравця)&nbsp;до&nbsp;різних «листків» є&nbsp;різними, й&nbsp;кількості проміжних вершин-рішень у&nbsp;цих до́&nbsp;різних шляхах можуть бути різними (однаковими теж можуть).

## Вхідні дані
Єдиний рядок, який містить дерево, закодоване таким способом:
1.  кожен окремий вузол-«листок» подається у&nbsp;вигляді ~(p_1 \,\, p_2)~, тобто: відкривна кругла дужка, величина виграшу 1-го гравця, пробіл, величина виграшу 2-го гравця, закривна кругла дужка;
2.  кожен вузол, що&nbsp;не&nbsp;є&nbsp;«листком» (отже,&nbsp;в&nbsp;ньому приймається рішення&nbsp;й&nbsp;різні варіанти ведуть&nbsp;до&nbsp;різних подальших вузлів) подається у&nbsp;вигляді: відкривна квадратна (якщо ходить 1-й&nbsp;гравець) чи&nbsp;кутова (якщо 2-й) дужка, пробіл, код вузла, куди веде перший варіант рішення, пробіл, код вузла, куди веде *дру́гий* варіант рішення, пробіл, ..., код вузла, куди веде останній варіант рішення, пробіл, закривна квадратна чи&nbsp;кутова дужка (так само, `]` для 1-го&nbsp;і&nbsp;`>` для 2-го).
    При&nbsp;цьому вкладені коди вузлів можуть відповідати чи&nbsp;то&nbsp;попередньому пункту (якщо вони вже не&nbsp;мають розгалужень), чи&nbsp;то&nbsp;поточному (якщо мають).

Наприклад, `[ (2 3) (4 5) (6 1) ]` подає дерево, де&nbsp;єдиний проміжний вузол має розгалуження&nbsp;на&nbsp;три варіанти, які всі є&nbsp;«листками», виграші яких становлять
2 для 1-го&nbsp;і&nbsp;3 для 2-го,
4 для 1-го&nbsp;і&nbsp;5 для 2-го,
6 для 1-го&nbsp;і&nbsp;1 для 2-го.

Гарантовано, що:
1.  дерево містить щонайменше один вузол;
2.  рядок, що&nbsp;кодує дерево, має не&nbsp;більше ~10^5~ символів (усіх, включно&nbsp;з&nbsp;пробілами та&nbsp;дужками);
3.  для проміжних вузлів, кількість варіантів вибору перебуває&nbsp;в&nbsp;межах від&nbsp;2 до&nbsp;6;
4.  всі виграші обох гравців (рахуючи по&nbsp;всім вузлам-«листкам») є&nbsp;різними числами, кожне&nbsp;з&nbsp;яких поміщається у&nbsp;32-бітовий знаковий

## Вихідні дані
Програма виводить два числа&nbsp;в&nbsp;одному рядку, розділені пропуском: виграші, які мають отримати 1-й&nbsp;та&nbsp;2-й&nbsp;гравці відповідно, якщо застосувати описаний алгоритм зворотньої індукції.

## Приклади

**Вхідні дані:**
```
[ < [ (-12 50) (-10 1) ] (25 20) > < (-4 -2) (1 4) (40 -10) [ (10 25) (6 -7) ] > (-3 -2) ]
```

**Вихідні дані:**
```
25 20
```