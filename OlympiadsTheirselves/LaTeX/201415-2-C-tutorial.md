Тут треба акуратно писати досить велику, як для II етапу, програму, поєднуючи різні стандартні алгоритми. Але, не зважаючи на страшну назву ко-анаграмічно та інші громіздкості, тут не дуже-то й треба самому придумувати щось математичне. Якщо, звісно:

*   знати стандартний алгоритм перевірки простоти числа;
*   вміти *або перевіряти, чи* числа складаються з одних і тих самих цифр, *або генерувати перестановки* послідовності цифр.

Стандартний алгоритм перевірки простоти числа ~n~ (при ~n > 2~) --- пробувати ділити його на 2, 3, ..., `round`(~\sqrt{n}~), і якщо хоч раз поділилося без остачі --- число складене, якщо ні разу --- просте. Важливо перевіряти до кореня (а не до ~n~ чи ~n/2~), бо це значно менше (див. також стор.).

Перевіряти, чи числа складаються з одних і тих самих цифр у різному порядку, можна по-різному. Один з простих і зручних підходів --- відсортувати (наприклад, за неспаданням) цифри окремо одного з них, окремо іншого, й порівняти отримані відсортовані послідовності (вони рівні тоді й тільки тоді, коли числа складаються з одних і тих самих цифр). Оскільки кількість цифр дуже маленька, нема смислу використовувати quickSort чи подібні ефективні алгоритми сортування, доречнішим буде сортування вставками чи навіть бульбашкове.

Таким чином, схема алгоритму може бути приблизно такою.
Функція (підпрограма) перевірити, чи є число ко-анаграмічно-простим має вигляд:

1.  Створити копію цього числа-аргумента у рядковому (`string`-овому) вигляді;
2.  Відсортувати цифри (символи рядка) за неспаданням;
3.  Перебрати усі числа з відповідною кількістю цифр, від 0...01 до 9...99, і для кожного з них:
    a.  перетворити у рядок (знову як копію, щоб не псувати оригінал);
    b.  теж відсортувати цифри числа за неспаданням;
    c.  якщо відсортовані послідовності виявилися різними --- значить, поточне число не є перестановкою цифр досліджуваного числа і його слід пропустити, а якщо однаковими --- запустити перевірку поточного числа на простоту.
Якщо перевірка у п. 3в хоча б один раз виявила, що число просте --- функція в цілому має повернути результат число є ко-анаграмічно-простим. Якщо жодного разу не виявила --- результат не є.

Тепер лишається тільки перевіряти, чи є ко-анаграмічно-простим саме введене число ~n~, потім ~n+1~, ~n+2~, ... Приклад реалізації --- `mGI9hm`.

Для цієї реалізації дуже складно і вивести асимптотичну оцінку часу роботи, і використати цю асимптотику для оцінювання конкретного часу роботи в мілісекундах. Наприклад, зовсім не ясно, як оцінити кількість ітерацій самого зовнішнього циклу (скільки чисел ~n~, ~n+1~, ... треба перебрати, щоб гарантовано знайти ко-анаграмічно-просте). У перевірці простоти, хоч і видно верхню межу циклу `round(sqrt(n))`, але ж розумна реалізація обриває цикл після першого знайденого дільника, і середня кількість ітерацій виявляється меншою (а наскільки --- не ясно); і так далі.

Програма може працювати швидше, якщо, замість перебору всіх чисел з відповідною кількістю цифр (від 0...01 до 9...99), відразу генерувати лише ті, що складаються з потрібного набору цифр. При обмеженні ~n < 9999~ це неважливо, тож не будемо описувати, як робити це вручну (охочі можуть знайти в літературі чи Інтернеті за назвою *генерація перестановок*, англ. *generate permutations*). У мові C++ така генерація є готова (функція `next_permutation` бібліотеки `algorithm`).
