**Чому в&nbsp;одному турі дві майже однакові задачі C, D?**
*Деякі* способи їх розв'язувань, справді, майже однакові. Але лобовий спосіб набирає далеко не&nbsp;всі бали, а&nbsp;серед ефективніших способів далеко не&nbsp;всі однаково придатні до&nbsp;обох задач.

**Це що, аж так важливо, чи&nbsp;знає учасник хитрі способи читання вхідних даних?**
І&nbsp;так, і&nbsp;ні. Що ж зробиш, як&nbsp;олімпіади з&nbsp;інформатики (програмування) вже більше 25&nbsp;років передбачають розрізнення більш ефективних розв'язків від менш ефективних, а&nbsp;саме в&nbsp;цих задачах швидкість введення/виведення істотно впливає на&nbsp;швидкість програми в&nbsp;цілому? Це не&nbsp;створено автором задачі навмисно, це сумний об'єктивний факт, який час від часу проявляється на&nbsp;оліміпадах (див. також стор. [text:io-streams-versus-scanf-printf], [sec:omnipresent-numbers]—[text:omnipresent-numbers-end]). І&nbsp;це точно *не* є істотною складовою оцінювання: якби хотіли це перевіряти, то інформацію про різні способи читання не&nbsp;доносили б різними способами безпосередньо на&nbsp;турі, а&nbsp;всіляко приховували. І&nbsp;якраз приховування було б несправедливим щодо тих учасників, які взагалі-то придумали й&nbsp;реалізували ефективний алгоритм, але програма не&nbsp;набирає гідний бал виключно тому, що&nbsp;повільно читає вхідні дані. Просто зменшити вхідні дані та/або збільшити обмеження часу — теж так собі пропозиція, бо тоді почали б надто легко проходити не&nbsp;досить ефективні алгоритми.

**Як&nbsp;досить легко набрати частину балів? Чому так набирається лише частина балів?**
Приклади нехитрих лобових розв'язків можна бачити за&nbsp;посиланнями
TODO: add IDEONE links here
Вони повинні проходити блоки 1–2, але не&nbsp;проходити жодного іншого блоку. Адже складність ~O(M \cdot N \cdot T)~ (див., зокрема, стор. [text:asymptotic-defs-begin]—[text:asymptotic-defs-end]) свідчить про крайню сумнівність вкладання виконання у&nbsp;секунду для одночасно максимальних N, M, T будь-якого з&nbsp;блоків 3–6. (Заперечення у&nbsp;стилі *ну не&nbsp;будуть же там геть усі прямокутники-запити вигляду "1 N 1 M", бо тоді взагалі всі суми-відповіді будуть однакові* нічогісінько не&nbsp;змінює: наприклад, у&nbsp;тесті з&nbsp;блоку 3 дуже навіть може бути, скажімо, 80% запитів, де ~1 < i_1 < 5~, ~20 < i_2 < 25~, ~1 < j_1 < 200~, ~1800 < j_2 < 2019~, і&nbsp;20% випадкових; це не&nbsp;сильно зменшить час, а&nbsp;однакових відповідей буде мало.)

```pascal
sum := 0;
for i:=i1 to i2 do
    for j:=j1 to j2 do
        sum:=sum+a[i][j];
```

**То що, рахувати суми вкладеними циклами, як&nbsp;праворуч — погано?**
Якби рахувати треба було один раз (чи&nbsp;двічі, чи&nbsp;навіть 10&nbsp;разів), це був би найдоцільніший (бо найприродніший) спосіб. Але ж просять порахувати T разів для (мабуть, різних) прямокутників-запитів. Найзагальніша ідея обох задач C, D — придумати, що&nbsp;б такого зробити з&nbsp;двовимірним масивом (одним! незмінним!), щоб, хай навіть витративши (*єдинократно!*) якісь додаткові зусилля/час/пам'ять (це, до&nbsp;речі, називають *передобробкою*), надалі могти швидше відповідати на&nbsp;самі запити. ***Як&nbsp;саме робити*** *передобробку і* ***що&nbsp;саме*** *вона* ***повинна дати*** — це вже складніше питання; різним варіантам відповіді на&nbsp;нього присвячена решта розбору цієї задачі та&nbsp;майже весь розбір наступної.

**Префіксні суми для одновимірного випадку.**
Розглянемо аналогічну (але простішу) задачу, де дано ***одно***вимірний масив і&nbsp;треба відповідати на&nbsp;багато запитів *яка сума всіх підряд елементів з&nbsp;~i~-го по&nbsp;~k~-й?* (до речі, така задача вже давно є на&nbsp;EjudgeCkipoName, як&nbsp;задача A [змагання 7](https://ejudge.ckipo.edu.ua/cgi-bin/register?action=212&contest_id=7&locale_id=2)).

| індекс | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :--- | --: | --: | --: | --: | --: | ---: | ---: | ---: | ---: |
| початковий масив `data` | | 3 | 1 | 4 | 1 | 5 | 9 | 2 | 6 |
| масив префіксних сум `sum` | 0 | 3 | 4 | 8 | 9 | 14 | 23 | 25 | 31 |

Там варто завести масив, кожен елемент якого має смисл *Яку суму мають усі елементи від початку до&nbsp;поточного?*. Чи починати, як&nbsp;у наведеному прикладі, нумерацію елементів самого масиву з&nbsp;1, а&nbsp;масиву сум з&nbsp;0 — питання дискусійне, такі деталі можна робити по-різному, в&nbsp;кожного способу свої переваги й вади; можна у&nbsp;програмі написати якось інакше, але у&nbsp;поясненнях буде саме так.

Маючи такий масив `sum`, можна рахувати суму будь-якого проміжку `data[j] + data[j+1] + ... + data[k]` *за&nbsp;одне віднімання*, як&nbsp;`sum[k] - sum[j-1]`, адже з&nbsp;«загальної» суми `data[1] + data[2] + ... + data[k]` якраз приберуть «непотрібну» суму `data[1] + data[2] + ... + data[j-1]`.

Що&nbsp;це дає для початкової задачі?
Навіть якщо реалізувати *лише* цей прийом, тобто порахувати префіксні суми для кожного рядка двовимірного масиву окремо, і&nbsp;відповіді на&nbsp;запити рахувати як&nbsp;«перебрати рядки прямокутника, й&nbsp;додати в&nbsp;циклі суми, знайдені одним відніманням кожна» — навіть тоді виходить ~O(N \cdot M + T \cdot N)~ дій, що&nbsp;повинно точно проходити блок 3, а&nbsp;при акуратній реалізації цілком може пройти також блок 5. (Звісно, для цього потрібно правильно рахувати масив префіксних сум, наприклад, якось у&nbsp;стилі `sum[i][0]:=0; for j:=1 to M do sum[i][j]:=sum[i][j-1]+a[i][j]`, ні в&nbsp;якому разі не&nbsp;запускаючи ще один цикл для кожного елементу префіксних сум.)

Блок 4 яскраво демонструє, що&nbsp;префіксні суми за&nbsp;рядками й&nbsp;перебір рядків — лише часткове покращення, і&nbsp;може підбити до&nbsp;того, щоб рахувати в&nbsp;одній програмі зразу два варіанти префіксних сум: за&nbsp;рядками і&nbsp;за стовпчиками. Що ж, якщо правильно вибирати, коли яка сума доцільніша, це може ще щось покращити: дозволити одній програмі пройти і&nbsp;блок 3, і&nbsp;блок 4; покращити «запас» часу при проходженні блоку 5 (але якщо він і&nbsp;так пройшов, то збільшення запасу ніяк не&nbsp;підвищує бали за&nbsp;задачу). Але само по&nbsp;собі це ще не&nbsp;повинно давати можливість пройти блок 6 і&nbsp;тим розв'язати задачу повністю.
У&nbsp;поєднанні зі ще якимись оптимізуючими прийомами, це вже можливо; наприклад, можна придумати такий прийом, як&nbsp;*за&nbsp;розмірами прямокутника поточного запиту, вибрати, який з&nbsp;трьох підходів має бути найшвидшим саме для нього: порахувати за&nbsp;рядками, чи&nbsp;порахувати за&nbsp;стовпчиками, чи&nbsp;(якщо він займає майже увесь основний масив) порахувати як&nbsp;різницю суми всього основного масиву, мінус сума «рамки», що&nbsp;не потрапляє, а&nbsp;суму «рамки», що&nbsp;не потрапляє, порахувати через горизонтальні та&nbsp;вертикальні префіксні суми*. Або такий прийом, як&nbsp;*порахувати усі ці горизонтальні та&nbsp;вертикальні префіксні суми і&nbsp;для кожного рядка/стовпчика окремо, і&nbsp;для шматків по&nbsp;10 рядків/стовпчиків підряд; це дасть можливість рахувати за&nbsp;одне віднімання суму не&nbsp;одного рядка/стовпчика, а&nbsp;зразу десяти (щоправда, якщо межі прямокутника-запиту не&nbsp;потрапили на&nbsp;ці красиві межі шматків по&nbsp;10 рядків/стовпчиків підряд, то по&nbsp;краям (чи&nbsp;з одного краю) треба буде пододавати також суми окремих рядків/стовпчиків)*. Або ще якийсь оптимізуючий прийом — їх тут може бути чимало різних. Але спосіб, наведений у&nbsp;наступному пункті, і&nbsp;простіший у&nbsp;плані технічної роботи, і&nbsp;переконливіший у&nbsp;плані теоретичного доведення часу його роботи.

```text
Початковий масив A:           Масив сум SUM:
    (j)  1  2  3  4               (j)  0   1   2   3   4
(i)                           (i)
 1       2  3  4  5            0       0   0   0   0   0
 2       3  1  4  1            1       0   2   5   9  14
 3       5  9  2  6            2       0   5   9  17  23
                               3       0  10  23  33  45
```

**Рекомендований 100&nbsp;%-й спосіб — двовимірне узагальнення префіксних сум.**
Замість незручно й&nbsp;неефективно працювати з&nbsp;багатьма окремими одновимірними префіксними сумами, краще здогадатися до&nbsp;такого їх двовимірного узагальнення: будемо для кожного елементу двовимірного масиву тримати суму всіх елементів, розміщених лівіше й&nbsp;вище за&nbsp;нього (конкретно у&nbsp;тому варіанті, який наведено на&nbsp;рисунку праворуч — включаючи рядок і&nbsp;стовпчик самого поточного елемента; наприклад, ~\texttt{sum[2][3]} = 17~ виражає суму ~(2+3+4) + (3+1+4)~; але, як&nbsp;і для одновимірного випадку, можуть бути варіанти, де індекси зсунуті якось інакше).

Коли такий масив уже побудований, то взнавати потрібну суму для прямокутника ~i_1~ ~i_2~ ~j_1~ ~j_2~ можна виразом `sum[i2][j2] - sum[i2][j1-1] - sum[i1-1][j2] + sum[i1-1][j1-1]`.

[Рисунок опущено]
Аргументація цього частково зображена на&nbsp;рисунку: щоб знайти суму області, виділеної рамкою, з&nbsp;суми області, виділеної сірим, віднімемо суму області, виділеної однією штриховкою, та&nbsp;суму області, виділеної іншою штриховкою; область, де штриховки накладаються, один раз додана й&nbsp;двічі віднята, тож, щоб це компенсувати, треба додати її.

Будувати цей масив `sum` можна за&nbsp;правилом
`sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j]`, яке обґрунтовується майже так само, тільки сіра незаштрихована область має складатися з&nbsp;єдиного елемента.

Тобто, заповнити масив `sum` можна за&nbsp;~\Theta(1)~ дій на&nbsp;кожен елемент, а&nbsp;відповідати на&nbsp;запити можна за&nbsp;~\Theta(1)~ дій на&nbsp;кожен запит. Читання вхідних даних та&nbsp;виведення результатів мають аналогічні оцінки часу. Таким чином, весь алгоритм має складність ~\Theta(N \cdot M+T)~. (До речі, якраз поєднання «час роботи пропорційний розміру вхідних даних» та&nbsp;«вхідні дані величезні» пояснює, чому в&nbsp;цій задачі аж так важливі швидкі введення/виведення: вони не&nbsp;«губляться» за&nbsp;рештою операцій.)

**То мені що, заводити масив розмірами 2020 на&nbsp;2020, незважаючи на&nbsp;те, що&nbsp;фактично таких тестів не&nbsp;буде?**
Якщо писати мовою програмування, в&nbsp;якій розмір масиву задається зарані (під час написання програми, отже, до&nbsp;прочитання вхідних даних) — так, тоді це єдиний вихід. Але ліміту пам'яті на&nbsp;це вистачає, із запасом. А&nbsp;якщо задавати розміри масивів після прочитання вхідних даних, таке питання, зазвичай, взагалі не&nbsp;виникає: прочитали N, M, задали розміри...; і&nbsp;в цій задачі ***не*** виникає рідкісної ситуації, коли заміна динамічної пам'яті на&nbsp;статичну дає істотне прискорення.

**А&nbsp;без префіксних сум чи&nbsp;їхніх прямокутних узагальнень набрати більше 30&nbsp;% балів не&nbsp;можна?**
Не те, щоб геть не&nbsp;можна; частина способів, описаних у&nbsp;наступній задачі, цілком годяться, щоб пройти у&nbsp;цій задачі, наприклад, блоки 1–5. Є&nbsp;й інші способи, геть невеликі модифікації яких повністю вирішують зразу обидві задачі. Але вони складніші за&nbsp;згадані тут. Тому, автор більш схиляється до&nbsp;того, що, мабуть, легше написати окремо спосіб для цієї задачі, якось оснований на&nbsp;префіксних сумах, і&nbsp;окремо інший спосіб для наступної задачі; але це сильно залежить від того, які саме ідеї вдалося пригадати чи&nbsp;придумати під час туру.

**А&nbsp;блоки 1 та&nbsp;2 взагалі чимсь відрізняються з&nbsp;точки зору розв'язування?**
З&nbsp;точки зору переважної більшості алгоритмів, нічим: майже будь-яка розумно написана програма, що&nbsp;проходить 1-й блок і&nbsp;не містить явних обмежень проти 2-го блоку, має проходити також і&nbsp;2-й. Але відмінність може проявитися для помилкових реалізацій, які: неправильно читають багатоцифрові числа; неправильно обробляють ситуацію, коли є лише один стовпчик чи&nbsp;лише один рядок; намагаються використати аж надто короткий тип даних (тут, зокрема, для когось може виявитися несподіванкою, що&nbsp;у FreePascal тип `integer` досі 16-бітовий, тому треба використовувати для самих елементів щонайменше `longint`, для сум `QWord` чи&nbsp;`int64`; див. також стор. [text:overflow-example] та&nbsp;стор. [text:notes-about-delphi-mode]); якось дуууже вже неефективно читають вхідні дані. Що ж, ситуації, коли програмі (нехай навіть мовою Python) не&nbsp;вистачає 2&nbsp;секунд на&nbsp;тому тесті, на&nbsp;якому найкраща наявна програма мовою C++ вкладається у&nbsp;0,001&nbsp;с (різниця у&nbsp;тисячі разів), все-таки є явною ознакою погано написаної програми...

