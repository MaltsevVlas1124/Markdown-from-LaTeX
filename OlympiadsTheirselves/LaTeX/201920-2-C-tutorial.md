**Чому в одному турі дві майже однакові задачі C, D?**
*Деякі* способи їх розв'язувань, справді, майже однакові. Але лобовий спосіб набирає далеко не всі бали, а серед ефективніших способів далеко не всі однаково придатні до обох задач.

**Це що, аж так важливо, чи знає учасник хитрі способи читання вхідних даних?**
І так, і ні. Що ж зробиш, як олімпіади з інформатики (програмування) вже більше 25 років передбачають розрізнення більш ефективних розв'язків від менш ефективних, а саме в цих задачах швидкість введення/виведення істотно впливає на швидкість програми в цілому? Це не створено автором задачі навмисно, це сумний об'єктивний факт, який час від часу проявляється на оліміпадах (див. також стор. [text:io-streams-versus-scanf-printf], [sec:omnipresent-numbers]--[text:omnipresent-numbers-end]). І це точно *не* є істотною складовою оцінювання: якби хотіли це перевіряти, то інформацію про різні способи читання не доносили б різними способами безпосередньо на турі, а всіляко приховували. І якраз приховування було б несправедливим щодо тих учасників, які взагалі-то придумали й реалізували ефективний алгоритм, але програма не набирає гідний бал виключно тому, що повільно читає вхідні дані. Просто зменшити вхідні дані та/або збільшити обмеження часу --- теж так собі пропозиція, бо тоді почали б надто легко проходити не досить ефективні алгоритми.

**Як досить легко набрати частину балів? Чому так набирається лише частина балів?**
Приклади нехитрих лобових розв'язків можна бачити за посиланнями
TODO: add IDEONE links here
Вони повинні проходити блоки 1–2, але не проходити жодного іншого блоку. Адже складність ~O(M \cdot N \cdot T)~ (див., зокрема, стор. [text:asymptotic-defs-begin]--[text:asymptotic-defs-end]) свідчить про крайню сумнівність вкладання виконання у секунду для одночасно максимальних N, M, T будь-якого з блоків 3–6. (Заперечення у стилі *ну не будуть же там геть усі прямокутники-запити вигляду "1 N 1 M", бо тоді взагалі всі суми-відповіді будуть однакові* нічогісінько не змінює: наприклад, у тесті з блоку 3 дуже навіть може бути, скажімо, 80% запитів, де ~1 < i_1 < 5~, ~20 < i_2 < 25~, ~1 < j_1 < 200~, ~1800 < j_2 < 2019~, і 20% випадкових; це не сильно зменшить час, а однакових відповідей буде мало.)

```pascal
sum := 0;
for i:=i1 to i2 do
    for j:=j1 to j2 do
        sum:=sum+a[i][j];
```

**То що, рахувати суми вкладеними циклами, як праворуч --- погано?**
Якби рахувати треба було один раз (чи двічі, чи навіть 10 разів), це був би найдоцільніший (бо найприродніший) спосіб. Але ж просять порахувати T разів для (мабуть, різних) прямокутників-запитів. Найзагальніша ідея обох задач C, D --- придумати, що б такого зробити з двовимірним масивом (одним! незмінним!), щоб, хай навіть витративши (*єдинократно!*) якісь додаткові зусилля/час/пам'ять (це, до речі, називають *передобробкою*), надалі могти швидше відповідати на самі запити. ***Як саме робити*** *передобробку і* ***що саме*** *вона* ***повинна дати*** --- це вже складніше питання; різним варіантам відповіді на нього присвячена решта розбору цієї задачі та майже весь розбір наступної.

**Префіксні суми для одновимірного випадку.**
Розглянемо аналогічну (але простішу) задачу, де дано ***одно***вимірний масив і треба відповідати на багато запитів *яка сума всіх підряд елементів з ~i~-го по ~k~-й?* (до речі, така задача вже давно є на EjudgeCkipoName, як задача A [змагання 7](https://ejudge.ckipo.edu.ua/cgi-bin/register?action=212&contest_id=7&locale_id=2)).

| індекс                          |   0 |   1 |   2 |   3 |   4 |    5 |    6 |    7 |    8 |
| :------------------------------ | --: | --: | --: | --: | --: | ---: | ---: | ---: | ---: |
| початковий масив `data`         |     |   3 |   1 |   4 |   1 |    5 |    9 |    2 |    6 |
| масив префіксних сум `sum`      |   0 |   3 |   4 |   8 |   9 |   14 |   23 |   25 |   31 |

Там варто завести масив, кожен елемент якого має смисл *Яку суму мають усі елементи від початку до поточного?*. Чи починати, як у наведеному прикладі, нумерацію елементів самого масиву з 1, а масиву сум з 0 --- питання дискусійне, такі деталі можна робити по-різному, в кожного способу свої переваги й вади; можна у програмі написати якось інакше, але у поясненнях буде саме так.

Маючи такий масив `sum`, можна рахувати суму будь-якого проміжку `data[j] + data[j+1] + ... + data[k]` *за одне віднімання*, як `sum[k] - sum[j-1]`, адже з «загальної» суми `data[1] + data[2] + ... + data[k]` якраз приберуть «непотрібну» суму `data[1] + data[2] + ... + data[j-1]`.

Що це дає для початкової задачі?
Навіть якщо реалізувати *лише* цей прийом, тобто порахувати префіксні суми для кожного рядка двовимірного масиву окремо, і відповіді на запити рахувати як «перебрати рядки прямокутника, й додати в циклі суми, знайдені одним відніманням кожна» --- навіть тоді виходить ~O(N \cdot M + T \cdot N)~ дій, що повинно точно проходити блок 3, а при акуратній реалізації цілком може пройти також блок 5. (Звісно, для цього потрібно правильно рахувати масив префіксних сум, наприклад, якось у стилі `sum[i][0]:=0; for j:=1 to M do sum[i][j]:=sum[i][j-1]+a[i][j]`, ні в якому разі не запускаючи ще один цикл для кожного елементу префіксних сум.)

Блок 4 яскраво демонструє, що префіксні суми за рядками й перебір рядків --- лише часткове покращення, і може підбити до того, щоб рахувати в одній програмі зразу два варіанти префіксних сум: за рядками і за стовпчиками. Що ж, якщо правильно вибирати, коли яка сума доцільніша, це може ще щось покращити: дозволити одній програмі пройти і блок 3, і блок 4; покращити «запас» часу при проходженні блоку 5 (але якщо він і так пройшов, то збільшення запасу ніяк не підвищує бали за задачу). Але само по собі це ще не повинно давати можливість пройти блок 6 і тим розв'язати задачу повністю.
У поєднанні зі ще якимись оптимізуючими прийомами, це вже можливо; наприклад, можна придумати такий прийом, як *за розмірами прямокутника поточного запиту, вибрати, який з трьох підходів має бути найшвидшим саме для нього: порахувати за рядками, чи порахувати за стовпчиками, чи (якщо він займає майже увесь основний масив) порахувати як різницю суми всього основного масиву, мінус сума «рамки», що не потрапляє, а суму «рамки», що не потрапляє, порахувати через горизонтальні та вертикальні префіксні суми*. Або такий прийом, як *порахувати усі ці горизонтальні та вертикальні префіксні суми і для кожного рядка/стовпчика окремо, і для шматків по 10 рядків/стовпчиків підряд; це дасть можливість рахувати за одне віднімання суму не одного рядка/стовпчика, а зразу десяти (щоправда, якщо межі прямокутника-запиту не потрапили на ці красиві межі шматків по 10 рядків/стовпчиків підряд, то по краям (чи з одного краю) треба буде пододавати також суми окремих рядків/стовпчиків)*. Або ще якийсь оптимізуючий прийом --- їх тут може бути чимало різних. Але спосіб, наведений у наступному пункті, і простіший у плані технічної роботи, і переконливіший у плані теоретичного доведення часу його роботи.

```text
Початковий масив A:           Масив сум SUM:
    (j)  1  2  3  4               (j)  0   1   2   3   4
(i)                           (i)
 1       2  3  4  5            0       0   0   0   0   0
 2       3  1  4  1            1       0   2   5   9  14
 3       5  9  2  6            2       0   5   9  17  23
                               3       0  10  23  33  45
```

**Рекомендований 100%-й спосіб --- двовимірне узагальнення префіксних сум.**
Замість незручно й неефективно працювати з багатьма окремими одновимірними префіксними сумами, краще здогадатися до такого їх двовимірного узагальнення: будемо для кожного елементу двовимірного масиву тримати суму всіх елементів, розміщених лівіше й вище за нього (конкретно у тому варіанті, який наведено на рисунку праворуч --- включаючи рядок і стовпчик самого поточного елемента; наприклад, ~\texttt{sum[2][3]} = 17~ виражає суму ~(2+3+4) + (3+1+4)~; але, як і для одновимірного випадку, можуть бути варіанти, де індекси зсунуті якось інакше).

Коли такий масив уже побудований, то взнавати потрібну суму для прямокутника ~i_1~ ~i_2~ ~j_1~ ~j_2~ можна виразом `sum[i2][j2] - sum[i2][j1-1] - sum[i1-1][j2] + sum[i1-1][j1-1]`.

[Рисунок опущено]
Аргументація цього частково зображена на рисунку: щоб знайти суму області, виділеної рамкою, з суми області, виділеної сірим, віднімемо суму області, виділеної однією штриховкою, та суму області, виділеної іншою штриховкою; область, де штриховки накладаються, один раз додана й двічі віднята, тож, щоб це компенсувати, треба додати її.

Будувати цей масив `sum` можна за правилом
`sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j]`, яке обґрунтовується майже так само, тільки сіра незаштрихована область має складатися з єдиного елемента.

Тобто, заповнити масив `sum` можна за ~\Theta(1)~ дій на кожен елемент, а відповідати на запити можна за ~\Theta(1)~ дій на кожен запит. Читання вхідних даних та виведення результатів мають аналогічні оцінки часу. Таким чином, весь алгоритм має складність ~\Theta(N \cdot M+T)~. (До речі, якраз поєднання «час роботи пропорційний розміру вхідних даних» та «вхідні дані величезні» пояснює, чому в цій задачі аж так важливі швидкі введення/виведення: вони не «губляться» за рештою операцій.)

**То мені що, заводити масив розмірами 2020 на 2020, незважаючи на те, що фактично таких тестів не буде?**
Якщо писати мовою програмування, в якій розмір масиву задається зарані (під час написання програми, отже, до прочитання вхідних даних) --- так, тоді це єдиний вихід. Але ліміту пам'яті на це вистачає, із запасом. А якщо задавати розміри масивів після прочитання вхідних даних, таке питання, зазвичай, взагалі не виникає: прочитали N, M, задали розміри...; і в цій задачі ***не*** виникає рідкісної ситуації, коли заміна динамічної пам'яті на статичну дає істотне прискорення.

**А без префіксних сум чи їхніх прямокутних узагальнень набрати більше 30% балів не можна?**
Не те, щоб геть не можна; частина способів, описаних у наступній задачі, цілком годяться, щоб пройти у цій задачі, наприклад, блоки 1–5. Є й інші способи, геть невеликі модифікації яких повністю вирішують зразу обидві задачі. Але вони складніші за згадані тут. Тому, автор більш схиляється до того, що, мабуть, легше написати окремо спосіб для цієї задачі, якось оснований на префіксних сумах, і окремо інший спосіб для наступної задачі; але це сильно залежить від того, які саме ідеї вдалося пригадати чи придумати під час туру.

**А блоки 1 та 2 взагалі чимсь відрізняються з точки зору розв'язування?**
З точки зору переважної більшості алгоритмів, нічим: майже будь-яка розумно написана програма, що проходить 1-й блок і не містить явних обмежень проти 2-го блоку, має проходити також і 2-й. Але відмінність може проявитися для помилкових реалізацій, які: неправильно читають багатоцифрові числа; неправильно обробляють ситуацію, коли є лише один стовпчик чи лише один рядок; намагаються використати аж надто короткий тип даних (тут, зокрема, для когось може виявитися несподіванкою, що у FreePascal тип `integer` досі 16-бітовий, тому треба використовувати для самих елементів щонайменше `longint`, для сум `QWord` чи `int64`; див. також стор. [text:overflow-example] та стор. [text:notes-about-delphi-mode]); якось дуууже вже неефективно читають вхідні дані. Що ж, ситуації, коли програмі (нехай навіть мовою Python) не вистачає 2 секунд на тому тесті, на якому найкраща наявна програма мовою C++ вкладається у 0,001 с (різниця у тисячі разів), все-таки є явною ознакою погано написаної програми...