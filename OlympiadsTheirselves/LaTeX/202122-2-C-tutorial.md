# Розбір задачі

**Основна рекомендована ідея на&nbsp;повні бали.**
Можна підтримувати лічильник, який в&nbsp;момент початку обробки рядка рівний 0, при кожній `(` збільшується на&nbsp;1, а&nbsp;при кожній `)` зменшується на&nbsp;1. Рядок правильний тоді&nbsp;й&nbsp;тільки тоді, коли виконуються обидві властивості: (1) наприкінці обробки всього рядка цей лічильник знову рівний 0; (2) за&nbsp;весь час обробки рядка лічильник ні&nbsp;разу не&nbsp;ставав строго від'ємним.

Щоб пройти частину `C2`, важливо не&nbsp;тримати в&nbsp;пам'яті одночасно весь рядок, а&nbsp;читати його символ за&nbsp;символом, і,&nbsp;обробивши поточний символ, тут&nbsp;же його забувати. Перевірено (ще до офіційного туру), що&nbsp;всіма мовами, оголошеними в&nbsp;пам'ятці як&nbsp;гарантовані (`g++`, `fpc`, `python3`, `java`) це написати можливо. Щоправда, для&nbsp;`python3` для&nbsp;цього довелося додатково збільшити ліміт пам'яті та&nbsp;ліміт часу (й&nbsp;на турі перевірка відбувалася на&nbsp;вже збільшених; суть у&nbsp;тому, що&nbsp;не&nbsp;було спроб учасників читати по&nbsp;одному символу…); також, для&nbsp;`python3` не&nbsp;вдалося написати код так, щоб&nbsp;один&nbsp;і&nbsp;той&nbsp;са́мий код проходив хоч `C1`, хоч `C2` (це&nbsp;й&nbsp;було однією з&nbsp;причин розділення однієї задачі `C` на&nbsp;технічно різні частини `C1` та&nbsp;`C2` в&nbsp;єджаджі).

**Альтернативний підхід, що&nbsp;дозволяє набрати значну частину балів.**
Досить природним є також такий розв'язок: *«поки можливо, видаляти всі входження `()`; початковий рядок був правильним тоді&nbsp;й&nbsp;тільки тоді, коли такі видалення закінчуються порожнім рядком»*. Він повільніший за&nbsp;вищезгаданий, особливо на&nbsp;вхідних даних, де&nbsp;велика вкладеність дужок. Початковим наміром було, щоб цей розв'язок набирав десь 120—140 балів зі&nbsp;180. Однак, через недогляд автора задачі, цей розв'язок міг набирати чи&nbsp;не&nbsp;набирати повний бал складової `C1` (180 балів), залежно від&nbsp;того, наскільки ефективно реалізована заміна підрядка у&nbsp;відповідному бібліотечному методі, через&nbsp;що&nbsp;виникла ситуація, що&nbsp;коли мова програмування забезпечує більш ефективну заміну підрядків, то&nbsp;цей алгоритм проходить усі&nbsp;тести частини `C1`, а&nbsp;коли менш ефективно, то&nbsp;не&nbsp;всі. Оскільки це&nbsp;з'ясувалося лише&nbsp;після того, як&nbsp;дехто з&nbsp;учасників отримав повний бал за&nbsp;такий розв'язок, було&nbsp;прийнято рішення так&nbsp;і&nbsp;залишити, бо&nbsp;інакше це&nbsp;було&nbsp;б відбирання вже&nbsp;виставлених балів, що&nbsp;украй небажано.

**А в&nbsp;яких ситуаціях може&nbsp;бути 170 балів зі&nbsp;180?**
Якщо дуже уважно прочитати умову, можна&nbsp;побачити, що&nbsp;в&nbsp;`C2` заборонено порожній рядок (жодного символа), а&nbsp;в&nbsp;`C1` він не&nbsp;заборонений (отже, дозволений)&nbsp;і&nbsp;формально задовольняє вимогам правильності; тобто, треба&nbsp;вміти обробляти ситуацію, коли серед рядків є&nbsp;порожній (що&nbsp;є&nbsp;проблемою, зокрема, якщо писати мовою C++&nbsp;і&nbsp;читати оператором `>>`), і&nbsp;виводити для&nbsp;порожніх рядків відповідь `1`.
