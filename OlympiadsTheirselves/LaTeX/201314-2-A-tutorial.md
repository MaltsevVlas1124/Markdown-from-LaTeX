## Примітки
Розглянемо два випадки:

- електричка їде 1-м вагоном уперед: тоді 1-й у порядку слідування вагон має напис №1, 2-й у порядку слідування --- напис №2, тощо. Тобто, ~i = j~ незалежно від кількості вагонів електрички.
- електричка їде ~N~-м вагоном уперед: тоді 1-й у порядку слідування вагон має напис №~N~, 2-й у порядку слідування --- напис №~(N-1)~, тощо. Тобто, ~i + j = N + 1~.

Звідси ясно, що при ~i \neq j~ точно має місце 2-й випадок, для якого ~N = i + j - 1~. Може здатися, ніби при ~i = j~ слід виводити `0` (без додаткової інформації визначити неможливо); але є виключення: при ~i = j = 12~, відповідь 12 (електрички не бувають довшими 12 вагонів). А при (~i = j~) `and` (~j < 12~), таки виводити `0`, бо така ситуація можлива при будь-якому ~N~ у межах ~j \le N \le 12~. Приклад реалізації: [IdeOne vIUkUt](https://ideone.com/vIUkUt) . Програма містить всього кілька дій (складність ≈ ~\Theta(1)~) і виконується миттєво.

Розв'язки, які виводили правильну відповідь при ~i \neq j~, а при ~i = j~ --- *завжди* `0`, оцінювалися на 180 балів з 200.ле в *обох* випадках пробіл замінює найпершу цифру та … найостаннішу … всі 9 осмислених цифр ідуть в `a`. Може спасти на думку читати у циклі окремі `char`-и; але при стандартних налаштуваннях `cin>>c` (`c` --- типу `char`) взагалі пропускає пропуски, і взнати його позицію неможливо. Один зі способів вирішення цієї проблеми --- перед читанням `char`-ів викликати `cin.unsetf(ios::skipws)`, щоб пропуски та переведення рядка таки читались у ті `char`-и. Інший --- використати функцію `getline(cin,s)` (`s` --- типу `string`); вона (як і `readln` мови Pascal) читає все, включаючи пробіли, до кінця рядка.