## Щодо «лобового» підходу.
Найочевидніший підхід (справді перебрати всі числа від ~A~ до ~B~, перетворити у двійкове подання і для кожної пари сусідніх справді порівняти й порахувати біти) і не такий простий (як, власне, порівнювати біти?), і не має шансів узяти повні бали, бо, навіть якби кожна пара чисел порівнювалася за один процесорний такт (насправді явно більше), все одно при ~A \approx 1~, ~B \approx 10^{10}~ це було б кілька секунд.

Оскільки використання того, що числа в комп'ютері *вже* у двійковій системі, буває корисним у багатьох інших ситуаціях, пропонуємо охочим подивитися в [d5w2Hx](https://ideone.com/d5w2Hx), як варто було б технічно реалізовувати цей підхід. Змінна `k` послідовно набуває значень ~1_2~, ~10_2~, ~100_2~, ...; «`&`» є побітовим `and`-ом; отже, `i&k` являє собою або 0 (коли відповідний біт числа `i` рівний 0), або `k` (якщо рівний 1); отже, умова `(i&k) != ((i+1)&k)` виражає, що черговий біт чисел `i` та `i+1` все ще рі***з***ний (не однаковий). Крім того, з ~(i+1) - i = 1~ випливає, що різними бітами в цих числах можуть бути *лише* кінець ~011...1~ в `i` та відповідний йому кінець ~100...0~ в `i+1` (кількість одиниць, що перетворюються у нулі, може бути різною, в т.ч. 0; потім рівно один нуль перетворюється в одиницю); як тільки деякий біт однаковий --- всі лівіші теж, цикл можна обривати.

І навіть така, досить вилизана у деталях, реалізація цього підходу набирає лише 50% балів.

## Повний розв'язок.
Розглянемо таблицю, в якій записані числа від 1 до ~18_{Dec} = 10010_2~ та кількості розрядів, які змінюються при переході *до* цього числа від попереднього.

З неї легко бачити, що для непарних чисел змінюється 1 розряд; парних, але не кратних 4, змінюються 2 розряди; кратних 4, але не кратних 8, змінюються 3 розряди; і т.д. (Це неважко й довести: коли число кратне ~2^k~, але не кратне ~2^{k+1}~, його двійковий запис закінчується на рівно ~k~ нулів; при переході до цього числа від попереднього, змінюються вони всі, та ще один біт.)

А звідси вже можна порахувати, що на всьому проміжку від 1 до деякого ~N~ шукана сума всіх кількостей змін розряду може бути порахована як

$$ K(N) = N + (N \text{ div } 2) + (N \text{ div } 2^2) + ... + (N \text{ div } 2^k) + ... $$

де `div` --- цілочисельне ділення; сума, хоч і завершується трикрапкою, фактично має лише приблизно ~\log_2 N~ доданків (далі нулі). Чому така формула відповідає тому, що було наведено у табличці та подальших міркуваннях? Бо ~N~ --- кількість взагалі всіх чисел у діапазоні, й для непарних вже пораховано правильно, а для всіх парних з потрібної кількості взято 1; далі, ~(N \text{ div } 2)~ --- кількість всіх парних чисел у діапазоні, й для парних не кратних 4 вже пораховано правильно (один раніше й один зараз), а для всіх кратних 4 з потрібної кількості взято 2; і т.д.

Ця формула працює лише **_від 1_** до деякого ~N~, а треба від ~A~ до ~B~. Тому суму від ~A~ до ~B~ варто виразити як ~K(B) - K(A)~ (у більшості схожих ситуацій, як наприклад у задачах на підрахунок кількості дільників у діапазоні, ~K(B) - K(A-1)~, з міркувань «~A~ у проміжку, його виключати не треба», а тут все-таки ~K(B) - K(A)~, бо перехід від ~A-1~ до ~A~ не входить у потрібний проміжок).

Реалізуйте описаний алгоритм самостійно. `K(N)` варто оформити функцією (підпрограмою), щоб могти викликати з різними значеннями аргумента, не дублюючи сам код обчислень згідно формули (1). Така реалізація повинна працювати практично миттєво, бо її складність всього лиш ~O(\log B + \log A) = O(\log B)~. Так що обмеження ~B < 10^{10}~ в цьому ракурсі сприймається як легкий тролінг, бо і вимагає того ж 64-бітового типу даних, і схиляє до пошуку дещо повільніших алгоритмів (як-то ~O(\sqrt{B})~). Що ж, так теж буває...
