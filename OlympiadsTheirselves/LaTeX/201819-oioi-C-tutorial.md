Нехай у купці одна, дві або три палички. Тоді за один хід можна забрати їх усі й цим виграти. Від суперника тут нічого не залежить.

Тепер нехай у купці чотири палички. Тоді після будь-якого допустимого правилами гри ходу супернику залишиться або ~4-1=3~ палички, або ~4-2=2~, або ~4-3=1~. Після чого, суперник зможе взяти усі палички одним ходом і тим виграти. Ми (1-й гравець) не можемо цьому перешкодити.

Таким чином, позиції 1 паличка, 2 палички та 3 палички *виграшні*: починаючи з них, можна виграти, і суперник з цим нічого не вдіє. А позиція 4 палички *програшна*: якщо суперник вміє грати, він точно виграє, і той, кому дісталося 4 палички, з цим нічого не вдіє.

Якщо у купці 5, 6 або 7 паличок, можна зробити такий хід, щоб після нього супернику дісталася купка з 4-х паличок (що, як ми вже знаємо, означає, що він нічого не зможе протиставити правильній грі свого суперника, тобто нашій правильній грі). Таким чином, позиції 5 паличок, 6 паличок та 7 паличок теж виграшні. Аналогічно показується, що позиція 8 паличок програшна. І так далі: позиції, де кількість паличок кратна 4, програшні (починаючи з них, перемогти грамотного суперника неможливо), а позиції, де кількість паличок не кратна 4, виграшні (треба забирати `n mod 4` паличок, і цим або виграємо негайно (при ~1 < n < 3~), або супернику дістанеться програшна позиція).

Аналіз гри часто цим і закінчують, а питання що робити, коли нам дісталася програшна позиція? або ігнорують, або відповідають на нього абияк. Зокрема, часто заявляють раз при ході з програшної гарантовано виграти неможливо, будемо відтягувати кінець, беручи щоразу лише по одній паличці: чим довше триватиме гра, тим більше шансів, що неідеальний суперник помилиться.

Але в умові не дарма сказано, що у приблизно половині тестів треба грати проти безграмотних програм-суперниць, *причому в різних тестах різних*. Серед цих безграмотних програм-суперниць є така, яка завжди намагається забирати якнайбільше паличок, тобто або 3, або, якщо їх всього лишилося менш, ніж 3, то всі. Правда, у *такої* суперниці можна виграти, маючи на початку програшну позицію? Але для цього треба, перебуваючи у програшній позиції, взяти не одну паличку, а 2 або 3... (Це не допомагає, якщо початкова кількість паличок ~=4~: програма-суперниця не встигає збитися; але при значно більших початкових кількостях паличок перехоплення ініціативи цілком реальне.)

Так само, як не можна у програшних позиціях завжди виводити 1, не можна й виводити завжди 2 чи завжди 3, бо серед інших програм-суперниць є та, що завжди намагається забирати дві палички (й тільки якщо лишилася всього одна, то забере її одну), а також та, що абсолютно завжди забирає одну паличку. Тому треба або робити хід із програшної позиції якимсь хитро залежним від того, з якої саме програшної позиції ходимо...

...або застосувати всемогутні випадкові числа: з виграшних позицій ходити, згідно з основним аналізом, ходом `n mod 4`, а з програшних — суто випадково, від 1 до 3. Це, звісно, не допоможе проти грамотного суперника, але ситуації, описані у двох попередніх абзацах, стануть неможливими, й у випадках, де це можливо, ініціатива перехоплюватиметься.

(Ще раз: тут *не* пропонується *завжди* ходити випадково; така програма майже завжди програвала б ідеальному супернику, котрий не помиляється. Пропонується у першу чергу дивитися на виграшність/програшність, а вже у випадку програшності, коли гарантій все одно нема, ходити випадково.)

У розв'язках цієї задачі якось трапилася кумедна помилка. Одна особа, бажаючи зробити числа якнайвипадковішими, писала перед кожним викликом `(rand()%3)+1` (згенерувати чергове псевдовипадкове число від 1 до 3) новий виклик `srand(time(NULL))` (переналаштувати генератор псевдовипадкових чисел). Така реалізація (мовою C++) програє згаданим суперникам вигляду намагатися завжди брати..., причому при різних запусках — різним суперникам (на різних тестах): то супернику, що намагається завжди брати 3, то тому, що намагається завжди брати 2, то тому, що завжди бере 1. Причина в тому, що `time(NULL)` залежить від поточного системного часу, але не наносекунд, які щоразу різні, а цілих секунд, які, як правило, однакові протягом усього виконання програми. Так і виходило, що генератор, щоразу однаково переініціалізований, видавав одне й те ж.

Розглянута в цій задачі гра має назву: *гра Баше*. Втім, цю задачу потроху розв'язували різні люди, внесок К. Г. Баше не є вирішальним, і назва гра Баше поширена, але не загальноприйнята.