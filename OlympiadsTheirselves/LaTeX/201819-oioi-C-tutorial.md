Нехай у&nbsp;купці одна, дві або три палички. Тоді за&nbsp;один хід можна забрати їх усі й&nbsp;цим виграти. Від суперника тут нічого не&nbsp;залежить.

Тепер нехай у&nbsp;купці чотири палички. Тоді після будь-якого допустимого правилами гри ходу супернику залишиться або ~4-1=3~&nbsp;палички, або ~4-2=2~, або ~4-3=1~. Після чого, суперник зможе взяти усі палички одним ходом і&nbsp;тим виграти. Ми (1-й гравець) не&nbsp;можемо цьому перешкодити.

Таким чином, позиції 1&nbsp;паличка, 2&nbsp;палички та&nbsp;3&nbsp;палички *виграшні*: починаючи з&nbsp;них, можна виграти, і&nbsp;суперник з&nbsp;цим нічого не&nbsp;вдіє. А&nbsp;позиція 4&nbsp;палички *програшна*: якщо суперник вміє грати, він точно виграє, і&nbsp;той, кому дісталося 4&nbsp;палички, з&nbsp;цим нічого не&nbsp;вдіє.

Якщо у&nbsp;купці 5, 6 або 7&nbsp;паличок, можна зробити такий хід, щоб після нього супернику дісталася купка з&nbsp;4-х&nbsp;паличок (що, як&nbsp;ми вже знаємо, означає, що&nbsp;він нічого не&nbsp;зможе протиставити правильній грі свого суперника, тобто нашій правильній грі). Таким чином, позиції 5&nbsp;паличок, 6&nbsp;паличок та&nbsp;7&nbsp;паличок теж виграшні. Аналогічно показується, що&nbsp;позиція 8&nbsp;паличок програшна. І&nbsp;так далі: позиції, де кількість паличок кратна 4, програшні (починаючи з&nbsp;них, перемогти грамотного суперника неможливо), а&nbsp;позиції, де кількість паличок не&nbsp;кратна 4, виграшні (треба забирати `n mod 4` паличок, і&nbsp;цим або виграємо негайно (при ~1 < n < 3~), або супернику дістанеться програшна позиція).

Аналіз гри часто цим і&nbsp;закінчують, а&nbsp;питання що&nbsp;робити, коли нам дісталася програшна позиція? або ігнорують, або відповідають на&nbsp;нього абияк. Зокрема, часто заявляють раз при ході з&nbsp;програшної гарантовано виграти неможливо, будемо відтягувати кінець, беручи щоразу лише по&nbsp;одній паличці: чим довше триватиме гра, тим більше шансів, що&nbsp;неідеальний суперник помилиться.

Але в&nbsp;умові не&nbsp;дарма сказано, що&nbsp;у приблизно половині тестів треба грати проти безграмотних програм-суперниць, *причому в&nbsp;різних тестах різних*. Серед цих безграмотних програм-суперниць є така, яка завжди намагається забирати якнайбільше паличок, тобто або 3, або, якщо їх всього лишилося менш, ніж 3, то всі. Правда, у&nbsp;*такої* суперниці можна виграти, маючи на&nbsp;початку програшну позицію? Але для цього треба, перебуваючи у&nbsp;програшній позиції, взяти не&nbsp;одну паличку, а&nbsp;2 або 3... (Це не&nbsp;допомагає, якщо початкова кількість паличок ~=4~: програма-суперниця не&nbsp;встигає збитися; але при значно більших початкових кількостях паличок перехоплення ініціативи цілком реальне.)

Так само, як&nbsp;не можна у&nbsp;програшних позиціях завжди виводити 1, не&nbsp;можна й&nbsp;виводити завжди 2 чи&nbsp;завжди 3, бо серед інших програм-суперниць є та, що&nbsp;завжди намагається забирати дві палички (й&nbsp;тільки якщо лишилася всього одна, то забере її одну), а&nbsp;також та, що&nbsp;абсолютно завжди забирає одну паличку. Тому треба або робити хід із програшної позиції якимсь хитро залежним від того, з&nbsp;якої саме програшної позиції ходимо...

...або застосувати всемогутні випадкові числа: з&nbsp;виграшних позицій ходити, згідно з&nbsp;основним аналізом, ходом `n mod 4`, а&nbsp;з програшних — суто випадково, від 1 до&nbsp;3. Це, звісно, не&nbsp;допоможе проти грамотного суперника, але ситуації, описані у&nbsp;двох попередніх абзацах, стануть неможливими, й&nbsp;у випадках, де це можливо, ініціатива перехоплюватиметься.

(Ще раз: тут *не* пропонується *завжди* ходити випадково; така програма майже завжди програвала б ідеальному супернику, котрий не&nbsp;помиляється. Пропонується у&nbsp;першу чергу дивитися на&nbsp;виграшність/програшність, а&nbsp;вже у&nbsp;випадку програшності, коли гарантій все одно нема, ходити випадково.)

У&nbsp;розв'язках цієї задачі якось трапилася кумедна помилка. Одна особа, бажаючи зробити числа якнайвипадковішими, писала перед кожним викликом `(rand()%3)+1` (згенерувати чергове псевдовипадкове число від 1 до&nbsp;3) новий виклик `srand(time(NULL))` (переналаштувати генератор псевдовипадкових чисел). Така реалізація (мовою C++) програє згаданим суперникам вигляду намагатися завжди брати..., причому при різних запусках — різним суперникам (на&nbsp;різних тестах): то супернику, що&nbsp;намагається завжди брати 3, то тому, що&nbsp;намагається завжди брати 2, то тому, що&nbsp;завжди бере 1. Причина в&nbsp;тому, що&nbsp;`time(NULL)` залежить від поточного системного часу, але не&nbsp;наносекунд, які щоразу різні, а&nbsp;цілих секунд, які, як&nbsp;правило, однакові протягом усього виконання програми. Так і&nbsp;виходило, що&nbsp;генератор, щоразу однаково переініціалізований, видавав одне й&nbsp;те ж.

Розглянута в&nbsp;цій задачі гра має назву: *гра Баше*. Втім, цю задачу потроху розв'язували різні люди, внесок К.&nbsp;Г.&nbsp;Баше не&nbsp;є вирішальним, і&nbsp;назва гра Баше поширена, але не&nbsp;загальноприйнята.

