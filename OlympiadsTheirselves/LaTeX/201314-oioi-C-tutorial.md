# Вказівки
Задача передбачає *перебір* — проби різних значень, з перевіркою, чи виконується рівність. Треба лише організувати це правильно.

Один з класичних способів уникати подвійних урахувань розкладень, у яких значення ~x~ та ~y~ лише обміняні місцями — враховувати лише ті, де ~x < y~.

Деякі учасники здавали реалізацію, наведену праворуч. Вона і працює надто довго, і може знаходити зайві розкладення. Роз'яснено, чому такий (~O(N^2)~) алгоритм очевидно не вкладеться у 1 сек. А — що таке переповнення, внаслідок яких `x*x+y*y=N` може виявитися `true` при, наприклад, ~x=1~, ~y=65537~, ~N=131074~.
```pascal
res:=0;
for x:=1 to N do
    for y:=1 to N do
        if x<=y then
            if x*x+y*y=N then
                res:=res+1;
```

Через помилку автора, задача вийшла простішою, ніж планувалося. Повний бал набирає в т. ч. й вилизана у деталях програма, де принципова оптимізація лише одна: верхні межі циклів змінені з ~N~ на ~\sqrt{N}~.
```pascal
res:=0;
sqrtN:=round(sqrt(N));
for x:=1 to sqrtN do
    for y:=x to sqrtN do
        if x*x+y*y=N then
            res:=res+1;
```

Все ж розглянемо можливу подальшу оптимізацію, яка зменшує складність з ~O(\sqrt{N}*\sqrt{N}) = O(N)~ до ~O(\sqrt{N})~. Коли ~x~ вибраний, рівність ~x^2+y^2=N~ не може виконатися для різних натуральних ~y~. Тож вкладеного цикла по ~y~ можна позбутися, замінивши на перевірку, чи ~\sqrt{N-x^2}~ ціле та ~>x~.

Перевірку, чи ~\sqrt{K}~ цілий, можна робити як `frac(sqrt(K))=0`. Або як `sqr(round(sqrt(K)))=K`. Теоретично, у 1-му виразі можливий підвох, якщо `sqrt` поверне значення з похибкою і `frac` верне не 0, де насправді 0, а у другому — якщо `round` матиме вужчий тип і виникне переповнення. Практично вони обидва працюють правильно.