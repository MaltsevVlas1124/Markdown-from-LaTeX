# Прямокутні суми

Дано прямокутну таблицю розмірами `N` рядків на `M` стовпчиків, елементи якої є натуральними числами. Потрібно ***БАГАТОКРАТНО*** знаходити суми всіх чисел, що потрапляють у деякі прямокутники цієї таблиці, утворені рядками з ~i_1~-го по ~i_2~-й та стовпчиками з ~j_1~-го по ~j_2~-й.

У цій задачі, алгоритмічна суть повністю повторює задачу C *Прямокутні суми* з ІІ (районного/міського) етапу Всеукраїнської олімпіади з інформатики (програмування) по Черкаській області, що відбувся 14.12.2019 (коротка суть наведена в цитаті праворуч, детальніше можна подивитися у змаганні 70 сайту EjudgeCkipoName).
Але значна частина технічних деталей організовані абсолютно інакше. Й мета цього комплекту з двох задач --- ознайомитися з цим іншим технічним форматом, котрий з 2018/19 н. р. наявний на III (обласному) та IV (фінальному) етапах Всеукраїнської учнівської олімпіади з інформатики (програмування), але досі не згадувався на змаганнях, що проводяться в межах EjudgeCkipoName.

| Мова    | Тип файлу | Прямий лінк на файл                                                                                            | Його потім здавати? |
| :------ | :-------- | :------------------------------------------------------------------------------------------------------------- | :------------------ |
| `g++`   | header    | [ejudge.ckipo.edu.ua/201920-2a-C-header-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-header-g++.cpp)       | Ні                  |
| `g++`   | sample    | [ejudge.ckipo.edu.ua/201920-2a-C-sample-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-g++.cpp)       | Так                 |
| `g++`   | footer    | [ejudge.ckipo.edu.ua/201920-2a-C-footer-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-g++.cpp)       | Ні                  |
| `fpc`   | header    | [ejudge.ckipo.edu.ua/201920-2a-C-header-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-header-fpc.pas)       | Ні                  |
| `fpc`   | sample    | [ejudge.ckipo.edu.ua/201920-2a-C-sample-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-fpc.pas)        | Так                 |
| `fpc`   | footer    | [ejudge.ckipo.edu.ua/201920-2a-C-footer-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-fpc.pas)        | Ні                  |
| `javac` | header    | [ejudge.ckipo.edu.ua/201920-2a-C-header-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-header-javac.java)  | Ні                  |
| `javac` | sample    | [ejudge.ckipo.edu.ua/201920-2a-C-sample-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-javac.java)  | Так                 |
| `javac` | footer    | [ejudge.ckipo.edu.ua/201920-2a-C-footer-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-javac.java)  | Ні                  |

Розв'язки цієї задачі можна здавати *лише* мовами `g++` (C++), `fpc` (Free Pascal, у режимі сумісності з Delphi), `javac` (Java).
Додавати інші мови програмування поки що не планується; чи буде це змінено в майбутньому, невідомо.
Скачайте за лінками, вказаними праворуч, файли згідно Вашої мови програмування.
**Здавати в ejudge на перевірку треба *лише* виправлений *фрагмент* програми, відповідний вмісту *sample*.**
Відповідно, редагувати слід у першу чергу його, бо при перевірці на ejudge будуть використані header та footer, підготовлені журі, а не відредаговані Вами. (Причому, header буде в точності такий, як наведено за посиланням, а footer буде дещо відрізнятися, й Вам не повідомляється, як саме.)

**Протокол взаємодії (опис для C++).**

*Перелік доступних Вам функцій, підготовлених журі.*

- `vector<vector<int> > getArray(void)` --- повертає масив, над елементами якого потрібно виконувати операції знаходження сум прямокутників-запитів. Нумерація рядків та стовпчиків починається з 0.

Якщо Ви виконаєте у своєму коді дію `vector<vector<int> > arr = getArray();`, то надалі зможете взнавати кількість рядків як `arr.size()`, кількість стовпчиків як `arr[0].size()`, значення елемента з індексами `[i][j]` (при нумерації з 0) як `arr[i][j]`, тому всі три подальші функції цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не обов'язково користуватися цією функцією).

- `int getHeight(void)` --- повертає кількість рядків у масиві.
- `int getWidth(void)` --- повертає кількість стовпчиків у масиві.
- `int getElement(int i, int j)` --- повертає значення елемента, розміщеного в `i`-му рядку, `j`-му стовпчику (вважаючи, що нумерація рядків та стовпчиків починається з 0). Якщо значення `i` або `j` виходять за межі діапазону `0 <= i < getHeight()`, `0 <= j < getWidth()`, виклик `getElement(i,j)` повертає 0.

Усі ці функції є просто функціями (а не методами якогось класу).

*Перелік функцій, які Ви зобов'язані реалізувати.*
- `void init(void)` --- гарантовано буде викликатися один раз, на початку (раніше всіх запитів на підрахунок суми прямокутника). До результатів діяльності цієї функції ніяких вимог нема, на Ваш розсуд.
- `long long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)` --- повинна повернути суму всіх елементів, що потрапляють у прямокутник з індексами рядків `iTop <= i < iAfterBottom`, стовпчиків `jLeft <= j < jAfterRight` (нумерація з 0, початок діапазону включно, кінець не включно).

Це *не* відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу (наприклад, прямокутник, який там описувався рядком вхідних даних "1 2 3 4", тут описується викликом `calcRectSum(0, 2, 2, 4)`); але, на думку автора задачі, для мови C++ так якраз природніше.

Обидві ці функції повинні бути просто функціями (а не методами якогось класу).

**Протокол взаємодії (опис для Pascal).**
Фрагмент header *містить* рядок `{$mode delphi}`, тому вся компіляція відбуватиметься в режимі (максимально можливої для Free Pascal) сумісності з Delphi; зокрема, це забезпечує, що тип `integer` 32-бітовий.

*Перелік доступних Вам типів та підпрограм, підготовлених журі.*

- `type Arr2D = array[1..5000,1..5000] of integer` --- Ви не зобов'язані скрізь користуватися лише такими масивами, але наступна процедура використовує саме цей тип.
- `procedure getArray(var arr : Arr2D; var N, M : integer)` --- надає переданому масиву той вміст, для елементів якого слід шукати суми прямокутників-запитів, а ще двом змінним --- розміри: спочатку (`N`) кількість рядків, потім (`M`) кількість стовпчиків. Нумерація рядків та стовпчиків починається з 1.

Оскільки і сам масив, і його розміри тут вже задані, всі три подальші функції цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не обов'язково користуватися цією процедурою).

- `function getHeight : integer` --- повертає кількість рядків у масиві.
- `function getWidth : integer` --- повертає кількість стовпчиків у масиві.
- `function getElement(i, j : integer) : integer` --- повертає значення елемента, розміщеного в `i`-му рядку, `j`-му стовпчику (вважаючи, що нумерація рядків та стовпчиків починається з 1). Якщо значення `i` або `j` виходять за межі діапазону `1 <= i <= getHeight`, `1 <= j <= getWidth`, виклик `getElement(i,j)` повертає 0.

Усі ці процедури/функції є просто процедурами/функціями (а не методами якогось класу).

*Перелік підпрограм, які Ви зобов'язані реалізувати.*
- `procedure init` --- гарантовано буде викликатися один раз, на початку (раніше всіх запитів на підрахунок суми прямокутника). До результатів діяльності цієї процедури ніяких вимог нема, на Ваш розсуд.
- `function calcRectSum(iTop, iBottom, jLeft, jRight : integer) : int64` --- повинна повернути суму всіх елементів, що потрапляють у прямокутник з індексами рядків `iTop <= i <= iBottom`, стовпчиків `jLeft <= j <= jRight` (нумерація з 1, усі межі включно; це якраз відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу, і вважається природнім для мови Pascal).

Ці процедура та функція повинні бути просто процедурою та функцією (а не методами якогось класу).

**Протокол взаємодії (опис для Java).**

*Перелік доступних Вам методів, підготовлених журі.*
Всі ці методи є статичними публічними класу `GetData`.

- `static public int[][] getArray()` --- повертає двовимірний масив (масив масивів), над елементами якого потрібно виконувати операції знаходження сум прямокутників-запитів. Нумерація рядків та стовпчиків починається з 0.

Якщо Ви виконаєте у своєму коді дію `int[][] arr = GetData.getArray();`, то надалі зможете взнавати кількість рядків як `arr.length`, кількість стовпчиків як `arr[0].length`, значення елемента з індексами `[i][j]` (при нумерації з 0) як `arr[i][j]`, тому всі три подальші методи цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не обов'язково користуватися цим методом).

- `static public int getHeight()` --- повертає кількість рядків у масиві.
- `static public int getWidth()` --- повертає кількість стовпчиків у масиві.
- `static public int getElement(int i, int j)` --- повертає значення елемента, розміщеного в `i`-му рядку, `j`-му стовпчику (вважаючи, що нумерація рядків та стовпчиків починається з 0). Якщо значення `i` або `j` виходять за межі діапазону `0 <= i < GetData.getHeight()`, `0 <= j < GetData.getWidth()`, виклик `GetData.getElement(i,j)` повертає 0.

Всі згадані тут методи є статичними публічними класу `GetData`.

*Перелік методів, які Ви зобов'язані реалізувати.*
Всі ці методи повинні бути статичними публічними класу `UserSolver`. Весь клас повинен ***не*** бути публічним.
- `static public void init()` --- гарантовано буде викликатися один раз, на початку (раніше всіх запитів на підрахунок суми прямокутника). До результатів діяльності цього метода ніяких вимог нема, на Ваш розсуд.
- `static public long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)` --- повинна повернути суму всіх елементів, що потрапляють у прямокутник з індексами рядків `iTop <= i < iAfterBottom`, `jLeft <= j < jAfterRight` (нумерація з 0, початок діапазону включно, кінець не включно).

Це *не* відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу (наприклад, прямокутник, який там описувався рядком вхідних даних "1 2 3 4", тут описується викликом `UserSolver.calcRectSum(0, 2, 2, 4)`); але, на думку автора задачі, для мови Java так якраз природніше.

Всі згадані тут методи повинні бути статичними публічними класу `UserSolver`.
Весь клас повинен ***не*** бути публічним. Ви можете, якщо бажаєте, додавати у клас `UserSolver` свої методи та/або поля, робити їх будь-якого рівня доступу (`public`/`protected`/`private`), але обов'язково ***лише статичними***. Примірники (instances) цього класу створюватися ***не*** будуть.

| блок | тести   | обмеження                                                         | передумови    | бали |
| :--- | :-------| :---------------------------------------------------------------- | :------------ | :--- |
| 1    | 1-5     | `2 <= N,M,T,a_ij <= 9`                                            | нема          | 10%  |
| 2    | 6-10    | `1 <= N,M,T <= 100`; `1 <= a_ij <= 10^4`                          | блок 1        | 10%  |
| 3    | 11-15   | `1 <= N <= 25`; `100 <= M <= 2019`; `10^3 <= T,a_ij <= 10^5`      | блок 1        | 10%  |
| 4    | 16-20   | `100 <= N <= 2019`; `1 <= M <= 25`; `10^3 <= T,a_ij <= 10^5`      | блок 1        | 10%  |
| 5    | 21-23   | `100 <= N,M <= 400`; `123 <= T,a_ij <= 12345`                     | блоки 1-2     | 10%  |
| 6    | 24-27   | `400 <= N,M <= 700`; `12345 <= T <= 222555`; `1 <= a_ij <= 10^9`  | блоки 1-2, 5  | 15%  |
| 7    | 28-31   | `1000 <= N,M <= 2019`; `12345 <= T <= 10^5`; `1 <= a_ij <= 10^9`  | блоки 1-6     | 15%  |
| 8    | 32-35   | `4000 <= N,M <= 5000`; `10^5 <= T <= 10^6`; `1 <= a_ij <= 10^9`   | блоки 1-7     | 20%  |

Оцінювання поблокове (бали за блок нараховуються лише в разі успішного проходження всіх тестів блоку).
Стовпчик *передумови* означає, що розв'язок запускатиметься і перевірятиметься на поточному блоці, лише якщо цей самий розв'язок успішно пройшов блоки, згадані в передумовах.
Нерівності через кому (як-то *`100 <= N,M <= 400`*) означають, що всі перелічені через кому змінні перебувають в указаному діапазоні.
Обмеження на `T` вказують можливу кількість викликів `calcRectSum` для однієї й тієї ж таблиці.
Обмеження на `a_ij` вказують можливі значення елементів таблиці.

У блоках 1 та 2 тести рівносильні відповідним тестам задачі C *Прямокутні суми* ІІ (районного/міського) етапу Всеукраїнської олімпіади з інформатики по Черкаській області, що відбувся 14.12.2019; зокрема, 1-й тест 1-го блоку відповідає тесту, який там наведений в умові.
В подальших блоках тести інші.