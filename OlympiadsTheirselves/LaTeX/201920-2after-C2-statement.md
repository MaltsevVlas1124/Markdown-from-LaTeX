# Прямокутні суми

Дано прямокутну таблицю розмірами `N` рядків на&nbsp;`M` стовпчиків, елементи якої є натуральними числами. Потрібно ***БАГАТОКРАТНО*** знаходити суми всіх чисел, що&nbsp;потрапляють у&nbsp;деякі прямокутники цієї таблиці, утворені рядками з&nbsp;~i_1~-го по&nbsp;~i_2~-й та&nbsp;стовпчиками з&nbsp;~j_1~-го по&nbsp;~j_2~-й.

У&nbsp;цій задачі, алгоритмічна суть повністю повторює задачу C *Прямокутні суми* з&nbsp;ІІ (районного/міського) етапу Всеукраїнської олімпіади з&nbsp;інформатики (програмування) по&nbsp;Черкаській області, що&nbsp;відбувся 14.12.2019 (коротка суть наведена в&nbsp;цитаті праворуч, детальніше можна подивитися у&nbsp;змаганні 70 сайту EjudgeCkipoName).
Але значна частина технічних деталей організовані абсолютно інакше. Й&nbsp;мета цього комплекту з&nbsp;двох задач — ознайомитися з&nbsp;цим іншим технічним форматом, котрий з&nbsp;2018/19 н. р. наявний на&nbsp;III (обласному) та&nbsp;IV (фінальному) етапах Всеукраїнської учнівської олімпіади з&nbsp;інформатики (програмування), але досі не&nbsp;згадувався на&nbsp;змаганнях, що&nbsp;проводяться в&nbsp;межах EjudgeCkipoName.

| Мова | Тип файлу | Прямий лінк на&nbsp;файл | Його потім здавати? |
| :--- | :--- | :--- | :--- |
| `g++` | header | [ejudge.ckipo.edu.ua/201920-2a-C-header-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-header-g++.cpp) | Ні |
| `g++` | sample | [ejudge.ckipo.edu.ua/201920-2a-C-sample-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-g++.cpp) | Так |
| `g++` | footer | [ejudge.ckipo.edu.ua/201920-2a-C-footer-g++.cpp](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-g++.cpp) | Ні |
| `fpc` | header | [ejudge.ckipo.edu.ua/201920-2a-C-header-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-header-fpc.pas) | Ні |
| `fpc` | sample | [ejudge.ckipo.edu.ua/201920-2a-C-sample-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-fpc.pas) | Так |
| `fpc` | footer | [ejudge.ckipo.edu.ua/201920-2a-C-footer-fpc.pas](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-fpc.pas) | Ні |
| `javac` | header | [ejudge.ckipo.edu.ua/201920-2a-C-header-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-header-javac.java) | Ні |
| `javac` | sample | [ejudge.ckipo.edu.ua/201920-2a-C-sample-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-sample-javac.java) | Так |
| `javac` | footer | [ejudge.ckipo.edu.ua/201920-2a-C-footer-javac.java](https://ejudge.ckipo.edu.ua/201920-2a-C-footer-javac.java) | Ні |

Розв'язки цієї задачі можна здавати *лише* мовами `g++` (C++), `fpc` (Free Pascal, у&nbsp;режимі сумісності з&nbsp;Delphi), `javac` (Java).
Додавати інші мови програмування поки що&nbsp;не планується; чи&nbsp;буде це змінено в&nbsp;майбутньому, невідомо.
Скачайте за&nbsp;лінками, вказаними праворуч, файли згідно Вашої мови програмування.
**Здавати в&nbsp;ejudge на&nbsp;перевірку треба *лише* виправлений *фрагмент* програми, відповідний вмісту *sample*.**
Відповідно, редагувати слід у&nbsp;першу чергу його, бо при перевірці на&nbsp;ejudge будуть використані header та&nbsp;footer, підготовлені журі, а&nbsp;не відредаговані Вами. (Причому, header буде в&nbsp;точності такий, як&nbsp;наведено за&nbsp;посиланням, а&nbsp;footer буде дещо відрізнятися, й&nbsp;Вам не&nbsp;повідомляється, як&nbsp;саме.)

**Протокол взаємодії (опис для C++).**

*Перелік доступних Вам функцій, підготовлених журі.*

- `vector<vector<int> > getArray(void)` — повертає масив, над елементами якого потрібно виконувати операції знаходження сум прямокутників-запитів. Нумерація рядків та&nbsp;стовпчиків починається з&nbsp;0.

Якщо Ви виконаєте у&nbsp;своєму коді дію `vector<vector<int> > arr = getArray();`, то надалі зможете взнавати кількість рядків як&nbsp;`arr.size()`, кількість стовпчиків як&nbsp;`arr[0].size()`, значення елемента з&nbsp;індексами `[i][j]` (при нумерації з&nbsp;0) як&nbsp;`arr[i][j]`, тому всі три подальші функції цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не&nbsp;обов'язково користуватися цією функцією).

- `int getHeight(void)` — повертає кількість рядків у&nbsp;масиві.
- `int getWidth(void)` — повертає кількість стовпчиків у&nbsp;масиві.
- `int getElement(int i, int j)` — повертає значення елемента, розміщеного в&nbsp;`i`-му рядку, `j`-му стовпчику (вважаючи, що&nbsp;нумерація рядків та&nbsp;стовпчиків починається з&nbsp;0). Якщо значення `i` або `j` виходять за&nbsp;межі діапазону `0 <= i < getHeight()`, `0 <= j < getWidth()`, виклик `getElement(i,j)` повертає 0.

Усі ці функції є просто функціями (а&nbsp;не методами якогось класу).

*Перелік функцій, які Ви зобов'язані реалізувати.*
- `void init(void)` — гарантовано буде викликатися один раз, на&nbsp;початку (раніше всіх запитів на&nbsp;підрахунок суми прямокутника). До результатів діяльності цієї функції ніяких вимог нема, на&nbsp;Ваш розсуд.
- `long long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)` — повинна повернути суму всіх елементів, що&nbsp;потрапляють у&nbsp;прямокутник з&nbsp;індексами рядків `iTop <= i < iAfterBottom`, стовпчиків `jLeft <= j < jAfterRight` (нумерація з&nbsp;0, початок діапазону включно, кінець не&nbsp;включно).

Це *не* відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу (наприклад, прямокутник, який там описувався рядком вхідних даних "1 2 3 4", тут описується викликом `calcRectSum(0, 2, 2, 4)`); але, на&nbsp;думку автора задачі, для мови C++ так якраз природніше.

Обидві ці функції повинні бути просто функціями (а&nbsp;не методами якогось класу).

**Протокол взаємодії (опис для Pascal).**
Фрагмент header *містить* рядок `{$mode delphi}`, тому вся компіляція відбуватиметься в&nbsp;режимі (максимально можливої для Free Pascal) сумісності з&nbsp;Delphi; зокрема, це забезпечує, що&nbsp;тип `integer` 32-бітовий.

*Перелік доступних Вам типів та&nbsp;підпрограм, підготовлених журі.*

- `type Arr2D = array[1..5000,1..5000] of integer` — Ви не&nbsp;зобов'язані скрізь користуватися лише такими масивами, але наступна процедура використовує саме цей тип.
- `procedure getArray(var arr : Arr2D; var N, M : integer)` — надає переданому масиву той вміст, для елементів якого слід шукати суми прямокутників-запитів, а&nbsp;ще двом змінним — розміри: спочатку (`N`) кількість рядків, потім (`M`) кількість стовпчиків. Нумерація рядків та&nbsp;стовпчиків починається з&nbsp;1.

Оскільки і&nbsp;сам масив, і&nbsp;його розміри тут вже задані, всі три подальші функції цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не&nbsp;обов'язково користуватися цією процедурою).

- `function getHeight : integer` — повертає кількість рядків у&nbsp;масиві.
- `function getWidth : integer` — повертає кількість стовпчиків у&nbsp;масиві.
- `function getElement(i, j : integer) : integer` — повертає значення елемента, розміщеного в&nbsp;`i`-му рядку, `j`-му стовпчику (вважаючи, що&nbsp;нумерація рядків та&nbsp;стовпчиків починається з&nbsp;1). Якщо значення `i` або `j` виходять за&nbsp;межі діапазону `1 <= i <= getHeight`, `1 <= j <= getWidth`, виклик `getElement(i,j)` повертає 0.

Усі ці процедури/функції є просто процедурами/функціями (а&nbsp;не методами якогось класу).

*Перелік підпрограм, які Ви зобов'язані реалізувати.*
- `procedure init` — гарантовано буде викликатися один раз, на&nbsp;початку (раніше всіх запитів на&nbsp;підрахунок суми прямокутника). До результатів діяльності цієї процедури ніяких вимог нема, на&nbsp;Ваш розсуд.
- `function calcRectSum(iTop, iBottom, jLeft, jRight : integer) : int64` — повинна повернути суму всіх елементів, що&nbsp;потрапляють у&nbsp;прямокутник з&nbsp;індексами рядків `iTop <= i <= iBottom`, стовпчиків `jLeft <= j <= jRight` (нумерація з&nbsp;1, усі межі включно; це якраз відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу, і&nbsp;вважається природнім для мови Pascal).

Ці процедура та&nbsp;функція повинні бути просто процедурою та&nbsp;функцією (а&nbsp;не методами якогось класу).

**Протокол взаємодії (опис для Java).**

*Перелік доступних Вам методів, підготовлених журі.*
Всі ці методи є статичними публічними класу `GetData`.

- `static public int[][] getArray()` — повертає двовимірний масив (масив масивів), над елементами якого потрібно виконувати операції знаходження сум прямокутників-запитів. Нумерація рядків та&nbsp;стовпчиків починається з&nbsp;0.

Якщо Ви виконаєте у&nbsp;своєму коді дію `int[][] arr = GetData.getArray();`, то надалі зможете взнавати кількість рядків як&nbsp;`arr.length`, кількість стовпчиків як&nbsp;`arr[0].length`, значення елемента з&nbsp;індексами `[i][j]` (при нумерації з&nbsp;0) як&nbsp;`arr[i][j]`, тому всі три подальші методи цього переліку насправді непотрібні. Але, якщо зручно, можете ними користуватися (тоді не&nbsp;обов'язково користуватися цим методом).

- `static public int getHeight()` — повертає кількість рядків у&nbsp;масиві.
- `static public int getWidth()` — повертає кількість стовпчиків у&nbsp;масиві.
- `static public int getElement(int i, int j)` — повертає значення елемента, розміщеного в&nbsp;`i`-му рядку, `j`-му стовпчику (вважаючи, що&nbsp;нумерація рядків та&nbsp;стовпчиків починається з&nbsp;0). Якщо значення `i` або `j` виходять за&nbsp;межі діапазону `0 <= i < GetData.getHeight()`, `0 <= j < GetData.getWidth()`, виклик `GetData.getElement(i,j)` повертає 0.

Всі згадані тут методи є статичними публічними класу `GetData`.

*Перелік методів, які Ви зобов'язані реалізувати.*
Всі ці методи повинні бути статичними публічними класу `UserSolver`. Весь клас повинен ***не*** бути публічним.
- `static public void init()` — гарантовано буде викликатися один раз, на&nbsp;початку (раніше всіх запитів на&nbsp;підрахунок суми прямокутника). До результатів діяльності цього метода ніяких вимог нема, на&nbsp;Ваш розсуд.
- `static public long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)` — повинна повернути суму всіх елементів, що&nbsp;потрапляють у&nbsp;прямокутник з&nbsp;індексами рядків `iTop <= i < iAfterBottom`, `jLeft <= j < jAfterRight` (нумерація з&nbsp;0, початок діапазону включно, кінець не&nbsp;включно).

Це *не* відповідає формату вхідних початкової задачі ІІ (районного/міського) етапу (наприклад, прямокутник, який там описувався рядком вхідних даних "1 2 3 4", тут описується викликом `UserSolver.calcRectSum(0, 2, 2, 4)`); але, на&nbsp;думку автора задачі, для мови Java так якраз природніше.

Всі згадані тут методи повинні бути статичними публічними класу `UserSolver`.
Весь клас повинен ***не*** бути публічним. Ви можете, якщо бажаєте, додавати у&nbsp;клас `UserSolver` свої методи та/або поля, робити їх будь-якого рівня доступу (`public`/`protected`/`private`), але обов'язково ***лише статичними***. Примірники (instances) цього класу створюватися ***не*** будуть.

| блок | тести | обмеження | передумови | бали |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 1-5 | `2 <= N,M,T,a_ij <= 9` | нема | 10&nbsp;% |
| 2 | 6-10 | `1 <= N,M,T <= 100`; `1 <= a_ij <= 10^4` | блок 1 | 10&nbsp;% |
| 3 | 11-15 | `1 <= N <= 25`; `100 <= M <= 2019`; `10^3 <= T,a_ij <= 10^5` | блок 1 | 10&nbsp;% |
| 4 | 16-20 | `100 <= N <= 2019`; `1 <= M <= 25`; `10^3 <= T,a_ij <= 10^5` | блок 1 | 10&nbsp;% |
| 5 | 21-23 | `100 <= N,M <= 400`; `123 <= T,a_ij <= 12345` | блоки 1-2 | 10&nbsp;% |
| 6 | 24-27 | `400 <= N,M <= 700`; `12345 <= T <= 222555`; `1 <= a_ij <= 10^9` | блоки 1-2, 5 | 15&nbsp;% |
| 7 | 28-31 | `1000 <= N,M <= 2019`; `12345 <= T <= 10^5`; `1 <= a_ij <= 10^9` | блоки 1-6 | 15&nbsp;% |
| 8 | 32-35 | `4000 <= N,M <= 5000`; `10^5 <= T <= 10^6`; `1 <= a_ij <= 10^9` | блоки 1-7 | 20&nbsp;% |

Оцінювання поблокове (бали за&nbsp;блок нараховуються лише в&nbsp;разі успішного проходження всіх тестів блоку).
Стовпчик *передумови* означає, що&nbsp;розв'язок запускатиметься і&nbsp;перевірятиметься на&nbsp;поточному блоці, лише якщо цей самий розв'язок успішно пройшов блоки, згадані в&nbsp;передумовах.
Нерівності через кому (як-то *`100 <= N,M,T,a_ij <= 9`*) означають, що&nbsp;всі перелічені через кому змінні перебувають в&nbsp;указаному діапазоні.
Обмеження на&nbsp;`T` вказують можливу кількість викликів `calcRectSum` для однієї й&nbsp;тієї ж таблиці.
Обмеження на&nbsp;`a_ij` вказують можливі значення елементів таблиці.

У&nbsp;блоках 1 та&nbsp;2 тести рівносильні відповідним тестам задачі C *Прямокутні суми* ІІ (районного/міського) етапу Всеукраїнської олімпіади з&nbsp;інформатики по&nbsp;Черкаській області, що&nbsp;відбувся 14.12.2019; зокрема, 1-й тест 1-го блоку відповідає тесту, який там наведений в&nbsp;умові.
В&nbsp;подальших блоках тести інші.

