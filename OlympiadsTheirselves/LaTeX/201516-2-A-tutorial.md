## Примітки

Для пошуку першого рядка відповіді слід реалізувати код, що знаходить номер купе за номером місця, й порівняти результати для двох введених місць.
Можна, наприклад, поділити (дробово) на 4, потім заокруглити вгору (мовами C/C++, `(int)(ceil(p/4.0))`).
Мовами, де стандартного аналога `ceil` нема, це можна виразити, наприклад, формулою `(p+3) div 4`, де `div` --- цілочисельне ділення.

Очевидно, місця з непарними номерами нижні, а з парними верхні, тобто при
`p%2==0` (на Pascal, `p mod 2=0`) `HIGH`, інакше `LOW`.
Є й інші способи перевірки парності, як-то функція `odd(p)` (Pascal) чи порівняння `(p&1)==1` (C/C++/Java/C#/Python), воно ж `(p and 1)=1` (Pascal), що дають `true` при ***не*** **парному** `p`; це працює,
спираючись на т. зв. *`побітовий and`*, деталі знайдіть самостійно).

Складність усього разом узятого алгоритму очевидно ~\Theta(1)~.

У [IdeOne 0iknfP](https://ideone.com/0iknfP)  визначення номера купе і виведення `LOW`/`HIGH` оформлені як підпрограми. Це не обов'язково, але дозволяє уникнути деяких прикрих помилок, як-то помилився у формулі визначення номера купе, скопіював неправильну, потім для одного з місць виправив, а для іншого забув. Тому, винесення таких дій у підпрограми вважається правильним стилем і прикладом т. зв. повторного використання коду (code reusing).