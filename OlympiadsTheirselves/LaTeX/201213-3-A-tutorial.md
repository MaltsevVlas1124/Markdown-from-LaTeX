Задачу в принципі можна розв'язувати по-різному, в тому числі й з використанням циклів, щоб перебирати можливі номер під'їзду й номер поверху (при ~N < 999~ це вкладеться в обмеження часу). Але пряма формула природніша, і, мабуть, простіша, тож зосередимось на ній.

Для мов програмування, де є заокруглення вгору (`ceil`, `Ceiling`, тощо), можна використати його (разом з діленням у типі з рухомою комою). Якби був лише один під'їзд, то можна було б казати, що на 1-му поверсі розміщено квартири з 1 по ~k~, на 2-му — з ~(k+1)~ по ~(2 \cdot k)~, тощо; отже, для квартир з 1-го поверху ~0 < n/s < 1~; з 2-го, ~1 < n/s < 2~; і т.д. Звідси, номер поверху можна *було б* виражати як `(int)(ceil(((double)n)/k))` (C/C++; частину дужок можна і прибрати; забезпечити, що ділення робиться в типі `double`, можна й іншими засобами, але якось це зробити треба), чи `ceil(N/k)` (Python3), тощо.

Оскільки під'їзд не завжди один, в точності ця формула малокорисна, але потрібні можна побудувати аналогічно. Скажімо, з того, що 1-й під'їзд містить квартири від 1 до ~s \cdot k~ (включно), 2-й — від ~s \cdot k + 1~ до ~2 \cdot s \cdot k~, і т.д., слідує, що визначити номер під'їзду можна виразом `(int)(ceil(((double)N)/(s*k)))` (C/C++), чи `ceil(N/(s*k))` (Python3), тощо. Якщо номер під'їзду вже пораховано і присвоєно у змінну (наприклад, `p`), можна обчислити номер квартири у межах під'їзду (в тих самих межах від 1 до ~s \cdot k~ включно) як `n - s*k*p`; позначимо цю величину як `n_p`, після чого номер поверху можна обчислити згідно раніше розглянутих міркувань, як `(int)(ceil(((double)n_p)/k))` (C/C++), чи `ceil(n_p/k)` (Python3), тощо.

А що робити, якщо писати на Паскалі, де нема заокруглення вгору? По-перше, якщо доступний PascalABC, там функція `Ceil` *є*; головний недолік PascalABC (що він помітно повільніший за Free Pascal) у цій задачі абсолютно не важливий. По-друге, ніщо не заважає переписати те саме, реалізувавши заокруглення вгору самому. Є щонайменше два способи виразити ~ceil(a/b)~:  
(А) `res := a div b; if a mod b <> 0 then inc(res);`  
(Б) `(a+b-1) div b`.

Варто відзначити: *якби нумерація квартир, поверхів і під'їздів була не з 1, а з 0, всі формули були б простіші*. А саме: номер під'їзду виражався б як `N/(s*k)` (С-подібними мовами) чи `N//(s*k)` (Python3) чи `N div (s*k)` (Pascal); номер поверху виражався б як `(N/k)%s` (С-подібними мовами) чи `(N//k)%s` (Python3) чи `(N div k) mod s` (Pascal). Власне, ці формули настільки простіші, що може мати смисл навіть перетворити прочитане `N` (зменшивши на 1), провести обчислення за цими формулами, й перетворити кожен з отриманих результатів, збільшивши на 1. (Само собою, перетворенням підлягають лише *номери* квартири, поверху й під'їзду, ні в якому разі не *кількості* ~s~ та ~k~.) А ще це пояснює, чому, хоча людям нумерувати з 0 незручно, більшість сучасних мов програмування мають безальтернативну нумерацію масивів з 0: таке спрощення перерахунків з'являється не лише в цій задачі, а й у багатьох схожих (зокрема, при перетворенні індексів багатовимірного масиву в адресу в пам'яті та зворотньо).
