Задача на реалізацію, тобто не треба нічого придумувати, лише прочитати й реалізувати. Приблизно як стандартний підрахунок суми, тільки врахувати ще початкову кількість шкіл. Наприклад, див. [XbSTUE](https://ideone.com/XbSTUE). Про смисл `ifdef` та `assign` у цьому коді див. стор.

Цей код реалізований так, щоб рахувати суму на ходу, *не* зберігаючи всі вхідні дані у масиві. Але, при обмеженні ~K < 100~ та автоматичній перевірці, учасник має повне право вибрати простіший для себе варіант (з масивом чи без). На олімпіадах часто вимагають ефективний код, але це мають бути ситуації, де ефективний код легко розрізняється від неефективного. Ця ситуація такою не є, бо нереально помітити зайву сотню 4-байтових чисел на фоні виконуваного файлу, який займає значно більше місця у пам'яті. Якби хотіли розрізнити засобами автоматичної перевірки, чи зумів учасник реалізувати таку програму без масива, давали б обмеження не ~K < 100~, а десь так ~K < 10^6~ (чи навіть ~K < 10^7~), і при цьому жорстке обмеження пам'яті.

А от забезпечити, щоб усі числа поміщалися (без переповнень) у тип, треба. Для більшості сучасних мов програмування стандартне ціле число вміщає в себе максимальне для цієї задачі ~101 \cdot 10^6~, для деяких мов тут може бути проблема (зокрема, для Паскаля; див. також стор. та).