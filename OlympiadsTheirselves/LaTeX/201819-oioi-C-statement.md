Є одна купка, яка спочатку містить ~N~&nbsp;паличок.
Двоє грають у&nbsp;таку гру.
Кожен з&nbsp;гравців на&nbsp;кожному своєму ході може забрати з&nbsp;купки або ~1~, або ~2~, або ~3~&nbsp;палички.
Ніяких інших варіантів ходу нема.
Ходять гравці по&nbsp;черзі, пропускати хід не&nbsp;можна.
Виграє той, хто забирає останню паличку (можливо, разом із ще однією або ще двома).

Напишіть програму, яка інтерактивно гратиме за&nbsp;першого гравця.

На&nbsp;початку, один раз, Ваша програма повинна прочитати одне ціле число в&nbsp;окремому рядку — початкову кількість паличок ~N~ (~1 < N < 12345~).
Потім вона повинна повторювати такий цикл:
1.  Вивести єдине число в&nbsp;окремому рядку — свій хід, тобто кількість паличок, які вона зараз забирає з&nbsp;купки. Це повинно бути ціле число від ~1~ до&nbsp;~3~, не&nbsp;більше за&nbsp;поточну кількість паличок у&nbsp;купці.
2.  Якщо після цього купка стає порожньою, вивести окремим рядком фразу `I won!` (без лапок, символ-у-символ згідно зразку) і&nbsp;завершити роботу.
3.  Інакше, прочитати хід програми-суперниці, тобто кількість паличок, які вона зараз забирає з&nbsp;купки (єдине ціле число, в&nbsp;окремому рядку). Гарантовано, що&nbsp;хід допустимий (є цілим числом від ~1~ до&nbsp;~3~ і&nbsp;не перевищує поточного залишку паличок у&nbsp;купці). Само собою, ця гарантія дійсна лише за&nbsp;умови, що&nbsp;Ваша програма правильно визначила, що&nbsp;гра ще не&nbsp;закінчилася.
4.  Якщо після цього купка стає порожньою, вивести фразу `You won...` (без лапок, символ-у-символ згідно зразку) і&nbsp;завершити роботу.

Все вищезгадане повинно повторюватися, доки не&nbsp;будуть забрані всі палички (тобто, доки якась із програм-гравців не&nbsp;виграє).
Програма-суперниця не&nbsp;виводить фраз `I won!` / `You won...` чи&nbsp;якихось їх аналогів.

Ця задача є інтерактивною:
Ваша програма не&nbsp;отримає всіх вхідних даних на&nbsp;початку,
а&nbsp;отримуватиме по&nbsp;мірі виконання доуточнення,
що&nbsp;залежатимуть від попередніх дій Вашої програми.
Тим не&nbsp;менш, *її перевірка буде **автоматичною***.
Тому, в&nbsp;цій програмі, як&nbsp;і в&nbsp;програмах — розв'язках інших задач,
теж слід *не* організовувати діалог інтуїтивно зрозумілим чином,
а&nbsp;чітко дотримуватися формату. Тільки це не&nbsp;формат вхідного та&nbsp;вихідного файлів,
а&nbsp;формат спілкування з&nbsp;програмою, яка грає роль суперника.

Настійливо рекомендується, щоб Ваша програма після кожного свого виведення
робила дію `flush(output)` (Pascal),
вона ж `cout.flush()` (C++),
вона ж `fflush(stdout)` (C),
вона ж `sys.stdout.flush()` (Python),
вона ж `System.out.flush()` (Java).
Це істотно зменшує ризик,
що&nbsp;проміжна відповідь застрягне десь по&nbsp;дорозі,
не&nbsp;дійшовши до&nbsp;програми-суперниці.

## Приклади
**Вхідні дані:**
```
5
2
```

**Вихідні дані:**
```
1
2
I won!
```
У&nbsp;купці з&nbsp;самого початку 5&nbsp;паличок.
Ваша програма забирає одну, лишається чотири;
програма-суперниця забирає дві, лишається дві;
Ваша програма забирає обидві, повідомляє про свій виграш і&nbsp;завершує роботу.

## Оцінювання
У&nbsp;приблизно половині тестів Ваша програма матиме справу з&nbsp;ідеальною програмою-суперницею, яка не&nbsp;робить помилок.
У&nbsp;іншій приблизно половині — з&nbsp;різними програмами-суперницями, які грати не&nbsp;вміють — тобто, роблять лише ходи, які дотримуються формальних вимог забирати лише від ~1~ до&nbsp;~3~&nbsp;паличок та&nbsp;забирати не&nbsp;більше паличок, ніж реально є у&nbsp;купці,
але&nbsp;можуть вибирати не&nbsp;найкращий з&nbsp;допустимих ходів, дотримуючись кожна своїх власних уявлень про те, як&nbsp;краще грати в&nbsp;цю гру.
Буде оцінюватися
як&nbsp;уміння Вашої програми виграти там, де це легко,
так і&nbsp;вміння Вашої програми достойно, згідно правил гри, програти,
так і&nbsp;вміння Вашої програми скористатися (теж згідно правил) помилками чи&nbsp;іншими неадекватностями програми-суперниці, якщо такі будуть.

За&nbsp;будь-яке порушення правил гри з&nbsp;боку Вашої програми, відповідний тест оцінюватиметься як&nbsp;не пройдений.

