Тут мається на увазі розбір особливостей задачі з урахуванням того, що вона дана у варіанті з header-ом та footer-ом; розбір суто алгоритмічної її складової можна знайти через повідомлення у згаданому змаганні 70 сайту EjudgeCkipoName або за [*цим прямим посиланням*](https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108).

**Короткий огляд основних властивостей підходу з header-ами та footer-ами**

1.  Фрагмент `sample`, який Ви маєте дописати, ***НЕ*** містить точки входа у програму (функції `main` (C++) / головної програми (Pascal) / метода `main` (Java)), і це слід так і зберегти. Точка входу (головна програма чи функція/метод `main`) все одно ***Є*** у частині footer (мовою Java --- частині header, але в будь-якому разі в частині, написаній автором задачі, а не Вами), тож якщо Ви напишите ще одну точку входу --- найімовірніше, програма просто не скомпілюється. А якщо і скомпілюється (це можливо, зокрема, мовою Паскаль, де все після `END.` головної програми ігнорується), то Ви не знаєте всіх особливостей, які відрізняють секретний footer від вказаного на початку умови. Зокрема (але не тільки), в цій задачі секретний footer читає вхідні дані з деякого файлу, і Вам свідомо не повідомляють, як він називається. Тож замінити розроблену журі точку входу своєю Ви, найімовірніше, не зможете (а якщо і зможете, то неясно, яка в тому користь).
2.  Фрагмент `sample`, який Ви маєте дописати, ***НЕ*** читає вхідні дані з клавіатури/файлу й ***НЕ*** виводить результат на екран чи у файл; це треба так і залишити; все це робить footer (написаний автором задачі, а не Вами). Тим паче, саме в цій задачі Ви не знаєте, звідки читати й куди виводити. А якби і знали, то *зайві* читання та/або виведення призводили б до порушення формату введення/виведення (яке, досить непередбачувано, може дати чи то вердикт Помилка виконання, чи то Неправильний формат відповіді, тощо).
3.  Фрагмент `sample`, який Ви маєте дописати, зобов'язаний містити реалізацію кожної з підпрограм (функцій/процедур/методів), які Вам дано завдання реалізувати. Навіть якщо Ви вважаєте, що така дія непотрібна для досягнення остаточного результату (що саме в цій задачі, насправді, не так) --- хоча б не прибирайте вже наявні оголошення й порожні реалізації.
4.  Фрагмент `sample`, який Ви маєте дописати, ***МОЖЕ***, якщо Вам так зручно, містити також додаткові Ваші підпрограми (функції/процедури/методів) та/або Ваші типи, включаючи класи.
5.  Фрагмент `sample`, який Ви маєте дописати, ***МОЖЕ***, якщо Вам так зручно, *містити організовану Вами додаткову інформацію, що зберігається між викликами тих підпрограм, які Вам слід реалізувати*.
    Це можуть бути змінні будь-яких типів, включно з масивами та/або об'єктами (примірниками класів):
    1.  для С++ та Pascal це можуть бути глобальні змінні;
    2.  для Java це можуть бути статичні поля всередині того класу, в якому Вам слід реалізувати вказані методи.
    (*Підказка*: варто, щоб підпрограма `init` заповнювала ті глобальні змінні чи статичні поля результатами передобробки, а підпрограма `calcRectSum` використовувала їх для свого пришвидшення.)
6.  Коментарі з текстом `TODO`, наявні у фрагменті `sample`, рекомендують саме там і дописувати Ваш код, але ні до чого істотного не зобов'язують. Їх можна прибирати (для компілятора це просто коментарі); можна (і нерідко треба) писати свій код також у деяких інших місцях фрагмента `sample`; тощо. Але якщо не вписувати свій код ні в які з місць, позначених коментарями `TODO`, правильного розв'язку не вийде.

**Як мені локально (на своєму комп'ютері) запускати код, поділений між трьома файлами?**

Можна просто склеїти (наприклад, копіюваннями та вставками тексту, або написавши у командному рядку `copy "201920-2a-C-header-g++.cpp"+"201920-2a-C-sample-g++.cpp"+"201920-2a-C-footer-g++.cpp" C-all.cpp` або ще якось) `header-`, `sample-` та `footer`-фрагменти (саме в цьому порядку) в один файл. Кому це зручно --- може так і робити (тим паче, що тепер є вибір --- чи традиційно здавати файл із розв'язком, чи потрібну частину коду виділяти й копіювати у середовищі програмування та вставляти безпосередньо у сторінку ejudge). Але в цього простого підходу є недолік: при кожній спробі надіслати розв'язок в ejudge треба вибирати й копіювати ту *частину* коду, яка є дописаною версією колишнього фрагменту `sample`. Це і займає час, і збільшує ризик помилитись і здати щось не те.
(Зазвичай, це призводитиме до помилки компіляції; але за деяких обставин можливі й якісь інші викривлення процесу перевірки, й аналіз результатів таких викривлених перевірок може змарнувати багато часу й зусиль. Особливо, мовою Pascal, де весь вміст файлу після `END.` головної програми ігнорується.)
Тому, непогано було б мати спосіб здавати в ejudge повний вміст усього файлу.

```cpp
#ifdef _DEBUG
... (багато рядків — увеcь вміст файлу
"201920-2a-C-header-g++.cpp") ...
#endif

... (багато рядків — увеcь вміст
відредагованого Вами колишнього файлу
"201920-2a-C-sample-g++.cpp") ...

#ifdef _DEBUG
... (багато рядків — увеcь вміст
(можливо, відредагованого Вами)
колишнього файлу
"201920-2a-C-footer-g++.cpp") ...
#endif
```
Один з не універсальних, але реальних способів такий: ***ЯКЩО*** Ви пишете мовою C++ і користуєтеся на своєму комп'ютері ***MICROSOFT VISUAL STUDIO В DEBUG-РЕЖИМІ***, можна робити, як вказано праворуч, і виходитиме, що фрагменти від `` `#ifdef _DEBUG` `` до `` `#endif` `` будуть компілюватися й виконуватися на Вашому локальному комп'ютері, але пропускатимуться при компіляції (а отже, й виконанні) на ejudge.
Якщо Ви хочете користуватися локально іншим середовищем програмування (або студією в іншому режимі), то для користування цим прийомом треба розібратися з так званою *умовною компіляцією*, і *самостійно* робити, щоб у Вашому середовищі програмування (не в цій самій програмі, яка здаватиметься в ejudge, а в середовищі (IDE), в якому Ви запускаєте цю програму на Вашому локальному комп'ютері) було означене (defined) деяке ім'я, не означене на сервері ejudge.

Для Pascal ніби й досить замінити `#ifdef ...` на `{$ifdef ...}` та `#endif` на `{$endif}`, але конкретно слово `_DEBUG`, найімовірніше, не спрацює. Треба знайти аналогічне слово, означене (defined) саме у Вашому середовищі, але не на ejudge (або зробити таке означення самостійно).

Як (і чи можна) зробити щось аналогічне для Java, автору тексту невідомо (умовної компіляції в Java, начебто, не існує, а просто розкласти різні класи по різним файлам не можна, бо для звичайної компіляції багатофайлового проєкту ті класи повинні бути `public`, а для тієї, що відбувається в ejudge, вони не можуть бути `public`).

Якщо хтось може запропонувати зручніші чи універсальніші способи --- прохання так і зробити (питанням у EjudgeCkipoName, чи [повідомленням користувачеві `IlyaCk`](http://codeforces.com/usertalk?other=IlyaCk) на сайті [`codeforces.com`](https://codeforces.com), чи ще якось).

**Редагувати можна ***ТІЛЬКИ*** фрагмент `sample`?**

Залежить від того, як і навіщо. Наприклад, підключити у header 100 бібліотек і використовувати їх у sample --- дуже погана ідея, бо хоч воно і працюватиме на локальному комп'ютері, на ejudge не скомпілюється, бо тих додаткових бібліотек як не було, так і нема у header-і, підготовленому журі.
Але, наприклад, якщо в наданому журі footer-і вхідні дані читаються з клавіатури, а Ви хочете з файлу (чи навпаки) --- *таке* редагування footer-а може бути доброю ідеєю; причому, Вам не треба буде при здачі в ejudge перероблювати спосіб введення на початковий, бо Ваші правки footer-а лишаться на Вашому комп'ютері й не вплинуть на перевірку на ejudge.

Є й чимало інших випадків, коли доцільно редагувати footer (див. далі);
потреба редагувати header з'являється значно рідше, але іноді все ж буває.
Наприклад, Ви можете підключити у своєму header-і бібліотеки, що будуть використовуватися лише у Вашому footer-і. Тільки тоді треба слідкувати, щоб не використати ті додаткові бібліотеки в основній частині, що здаватиметься в ejudge.

**Чи є ще якісь переваги для учасника в цього підходу з header-ами та footer-ами?**

Їх, насправді, чимало (хоч вони й незвичні та неочевидні тим, хто досі з таким не стикався;
само собою, незручності в такого підходу теж є, але зараз не про них).
Одна з таких переваг --- зникає дуже вже велика залежність часу (тривалості) роботи програми учасника від використаних засобів читання вхідних даних та виведення результатів (для C++, `scanf` та `printf` проти `cin` та `cout`; для java, поєднання `FileReader`, `BufferedReader` та `StreamTokenizer` проти `Scanner` --- такі зміни, будучи технічними, а не алгоритмічними, кардинально впливають на оцінку розв'язку, бо загальний час роботи всієї програми (найефективнішого з алгоритмів, двовимірного узагальнення префіксних сум; див. [*розбір алгоритмічної складової задачі*](https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108)) відрізняється не на відсотки і навіть не на десятки відсотків, а у багато разів).
Див. також наступний пункт.

**Зручність підходу з header-ами та footer-ами для порівняння результатів різних алгоритмів.**

(Часто, але не завжди, це основна перевага цього підходу з точки зору учасника.)
У цій задачі не проблема написати лобовий розв'язок, де `calcRectSum` додає всі значення відповідного прямокутника-запиту поелементно. Само собою, цей лобовий розв'язок не має шансів пройти щось більше, ніж блоки 1--2, тож для отримання більших балів слід писати щось ефективніше (див. [*розбір алгоритмічної складової задачі*](https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108)).
Те ефективніше виявляється складнішим (особливо, коли не читати готові формули у розборі, а самостійно придумувати їх під час туру), в ньому легше допуститися помилок, і з цим треба якось працювати. Зокрема, шукати помилки в ефективнішій&складнішій версії `calcRectSum`, якщо вона працює правильно часто, але не завжди, й ejudge це ловить, а Ви не бачите, *коли* виникають помилки.

```pascal
for i1:=1 to N do
    for i2:=i1 to N do
        for j1:=1 to M do
            for j2:=j1 to M do begin
                res1:=calcRectSum(i1,i2,j1,j2);
                res2:=calcRectSumSlow(i1,i2,j1,j2);
                if res1<>res2 then begin
                    ... ... ...;
                end
            end
```
Тут часто корисно робити, як праворуч: ефективнішу&складнішу `calcRectSum` розмістити у sample-фрагменті, а підпрограму з лобовим підходом назвати `calcRectSumSlow` та розмістити у footer-фрагменті; зробити, щоб у footer-фрагменті послідовність прямокутників-запитів не читалася зі вхідних даних, а перебиралися всі можливі варіанти, і при знаходженні відмінності результатів двох алгоритмів, наприклад, тут же виводилося, де саме (при яких `i1`, `i2`, `j1`, `j2`) це сталося. Й усе це можна організувати так, щоб sample-фрагмент лишався у вигляді, цілком готовому до негайної здачі в ejudge.

Звісно, такий запуск реалізацій і порівняння результатів --- не панацея; він не знайде помилок, однакових в обох реалізаціях (наприклад, коли і там, і там є однакове переповнення типу), чи якусь проблему, що виникає лише на настільки великих розмірах масиву та прямокутників-запитів, що чекати лобового підходу задовго... Але це все ж спосіб шукати помилки, доступний під час туру (навіть без ejudge!), і є чимало ситуацій, коли ним варто скористатися. Й у варіанті з header-ами та footer-ами все це робити зручніше, ніж у традиційному.

**У 72-му змаганні відкрита частина тестів, так вони в геть зовсім різному форматі; частина схожа на формат 70-го змагання (й то не зовсім), а частина геть не схожі.**

Так і є. Але учасникам просто не треба про це хвилюватися. Просто робіть ту частину, яка випливає з умові задачі та загальних правил і традицій алгоритмічних олімпіад (*реалізувати підпрограму `calcRectSum` якнайефективніше, враховуючи, що суми треба рахувати багатократно для різних прямокутників одного масиву, і що Вам дається можливість один раз зробити передобробку в підпрограмі `init`*), і не надто звертайте увагу на те, що там читається з файлу/клавіатури та виводиться на екран чи у файл.

А те, що у 72-му змаганні найбільші тести не читаються з файлу повністю, а частково читаються й частково догенеровуються у footer-і секретним для учасників способом --- насправді ще одна *перевага* підходу з header-ами та footer-ами. Адже це дозволяє різко зменшити (вже згадану і дуже істотну для традиційної версії цієї задачі з 70-го змагання) проблему, що читання вхідних даних і виведення результату займає дуже вже значну частину всього часу виконання програми. У ще більшій мірі стає правдою, що виграють ті, хто може запропонувати кращий спосіб вирішення основної задачі (реалізувати підпрограму `calcRectSum` якнайефективніше), а не ті, хто добре знає всякі прийоми швидкого читання, які в цілому корисні, але не мають ніякого стосунку до конкретної задачі.