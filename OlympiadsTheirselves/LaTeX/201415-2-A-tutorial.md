Діяти за принципом *«Викреслювати мінімальну цифру»* *неправильно* (всупереч підступним прикладам з умови, які провокують таку хибну думку.) Наприклад, із числа 9891 треба викреслити 8 і отримати 991, а викреслення мінімальної цифри 1 дасть не максимальне 989.

Оскільки розміри малі (кількість цифр ~< 5~, видаляється одна), можна просто перебрати всі варіанти викреслення однієї цифри (усе число без 1-ої, усе без 2-ої, тощо), і вибрати з них максимальний. Зручно (хоча й не обов'язково) перевести число у рядок (`string`), і вилучати символи у рядковому поданні. Реалізацію див. `jFBIM6`. При бажанні, її можна спростити, роблячи все виключно рядками. (Взагалі буває проблема *у числах ~7 < 10~, а у рядках `7` ~>~ `10`*, але *тут* вона не проявиться, бо кількості цифр усіх потрібних чисел однакові.)

Якщо мати лише мету розв'язати цю задачу при цих обмеженнях --- краще обмежитися першим правильним способом і не читати далі. А якщо мати бажання ще раз розглянути, як можна доводити правильність алгоритма --- тоді подальший текст важливий.

Ще є правильний розв’язок *«Знайти найлівіше місце, де зразу після меншої цифри йде більша, і викреслити меншу саме з цих двох; якщо жодного такого місця нема (наприклад, у числі 97752) --- викреслити останню цифру»*.

Занумеруємо цифри початкового числа зліва направо ~\overline{a_1a_2\dots{}a_n}~.
Розглянемо спочатку випадок *«нема жодного місця, щоб після меншої цифри йшла більша»*, тобто ~a_1 \ge a_2 \ge \dots \ge a_n~. Згідно алгоритму, треба викреслити ~a_n~, лишивши ~\overline{a_1a_2\dots{}a_{n-1}}~. Якщо всупереч алгоритму викреслити деяку ~a_j~ (~1 < j < n~), вийде ~\overline{a_1a_2\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}~. Початок ~\overline{a_1a_2\dots{}a_{j-1}}~ спільний, тож результат порівняння визначається частиною, де ~a_{j+1}~ замість ~a_j~, ~a_{j+2}~ замість ~a_{j+1}~, \dots, ~a_n~ замість ~a_{n-1}~.
Оскільки розглядаємо ситуацію ~a_1 \ge a_2 \ge \dots \ge a_n~, то або ~a_j > a_{j+1}~, або ~a_j = a_{j+1}~. При ~a_j > a_{j+1}~, число, отримане всупереч алгоритму, менше (гірше) отриманого згідно з алгоритмом, бо після спільного початку йде ~a_{j+1} < a_j~. Якщо ж ~a_j = a_{j+1}~, то можна приєднати цю цифру до спільного початку і повторити *всі* міркування для ~a_{j+2}~ замість ~a_{j+1}~. І так далі. Кінець кінцем, або десь отримаємо, що число всупереч алгоритму менше (гірше) числа згідно з алгоритмом, або дійдемо до ~a_j = a_{j+1} = \dots = a_n~, тобто викреслення ~a_j~ призводить до *того ж* результату, що алгоритм.

Лишилося розглянути випадок, коли місце, де ~a_i < a_{i+1}~, існує. Нехай ~i^{\star}~ --- найлівіша з таких позицій, тобто ~a_1 \ge a_2 \ge \dots \ge a_{i^{\star}}~ і (~a_{i^{\star}} < a_{i^{\star}+1}~). Невигідність видаляти замість ~a_{i^{\star}}~ деяку ~a_j~ при ~1 < j < i^{\star}~ доводиться аналогічно попередньому абзацу. Лишилося довести невигідність видаляти ~a_j~ при ~i^{\star} < j < n~, а це зовсім легко: згідно з алгоритмом отримуємо ~\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}+1}\dots{}a_{n}}~, всупереч --- ~\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}}\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}~, тобто початок ~\overline{a_1a_2\dots{}a_{i^{\star}-1}}~ спільний, потім ~a_{i^{\star}+1} > a_{i^{\star}}~. Розглянуті випадки покрили всі можливі ситуації, доведення успішно завершене.

---

Чи має другий алгоритм переваги над першим? При ~n < 99999~ --- ні. *Якби* числа були значно більшими (наприклад, до мільйона цифр; не ~n < 10^6~, а якби *кількість цифр* могла сягати мільйона) --- тоді виявилося б, що перший алгоритм правильний, але повільний, а другий правильний і ефективний. Асимптотичні оцінки: ~\Theta(L^2)~ для першого, ~\Theta(L)~ для другого, де ~L~ --- кількість цифр.﻿
