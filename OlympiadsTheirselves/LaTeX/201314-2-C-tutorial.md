Задачу можна розв'язати ручним аналізом випадків, але це сумнівний спосіб, доречний, лише коли нема кращих ідей. За посиланням [jjq2Pq](https://ideone.com/jjq2Pq) можна побачити трохи модифікований варіант програми, яку здав один з учасників. Він набирає 270 балів з 300, що з одного боку немало, але з іншого --- на аналіз випадків явно пішло багато часу, бали все одно не повні, а шукати помилку в *такому* нагромадженні --- невдячна справа.

Щоб уникнути такої ситуації, краще реалізувати осмислений алгоритм, який обробляє різні вхідні дані більш-менш однотипно.

Раз йдеться про мінімальні (за кількістю переходів) шляхи, природним є *пошук ушир* (він же *пошук у ширину*, англ. *breadth first search*, *BFS*). Застосувати BFS треба до неорієнтованого графа, вершини якого --- вершини куба зі значенням 1 (по яким можна проходити), ребра --- ті ребра куба, що поєднують такі вершини. Причому, раз питають не відстань (число), а шлях (послідовність вершин), потрібен варіант BFS, у якому запам'ятовують вершини-попередники та роблять відновлення шляху *зворотнім ходом*. Деталі знайдіть у літературі або Інтернеті.

Інший можливий спосіб --- перебір (наприклад, рекурсивний) усіх шляхів, що не містять повторень вершин. Приклад такого розв'язку --- [pihZzm](https://ideone.com/pihZzm). Детальніше про це можна прочитати в Інтернеті або літературі за назвами *пошук з поверненнями*, *бектрекінг* (рос. *пошук з поверненням*, англ. *back-tracking*). Взагалі кажучи, цим не дуже складним способом теоретично можна розв'язати дуже багато задач, але він часто працює надто довго, не вкладаючись в обмеження часу. А тут вкладається, бо вершин всього 8.

На жаль, ідея писати осмислений алгоритм, щоб обробляти різні вхідні дані однотипно мало придатна до заданої рисунком відповідності ребер куба його вершинам. Важко сформулювати, між якими саме вершинами є ребра. (Найкраще, що вдалося --- *Позначки вершин відрізняються або на 4, або на 1, але крім ~d \leftrightarrow e~, а крім названих, є ще ~a \leftrightarrow d~ і ~e \leftrightarrow h~*.) Мабуть, легше задати явний перелік (чи як у розв'язку з попереднього абзацу, чи вписати у текст програми константний масив --- матрицю суміжності графа, чи ще якось). Але це треба ретельно звіряти з умовою, бо успішна побудова шляхів у одній частині графа ніяк не перевіряє правильність задання ребер у іншій частині.

## Прості способи набрати частину балів.
Тести цієї задачі такі, що програма, яка, не вирішуючи задачу по суті, завжди виводить `NO`, набирає 90 балів з 300. Можливо, це й несправедливо багато. Але з умови (та з того, що у 2013 р. використовувалося лише потестове оцінювання) очевидно, що така програма мусила хоч щось та набрати; хто не міг розв'язати правильно --- мав би пошукати якісь такі варіанти. Трохи чесніший спосіб --- перевіряти, чи є вершини кінцями одного ребра, і якщо так, то виводити ці вершини, а якщо ні, то `NO`. Він набирав 150 балів (рівно половину).
