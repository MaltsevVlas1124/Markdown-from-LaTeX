# normalsize

Легенда задачі відірвана від життя, ці правила не мають нічого спільного з реальною генерацією паролів. Тим не менш, будемо користуватися термінами «пароль» і «номер паролю», раз вони введені в умові.

**Позбудемось окремих статусів літер і цифр, перейшовши до єдиного алфавіту.**
Правила про порядок можна спростити до таких:
1.  будемо вважати алфавітом `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`, `I`, `J`, `K`, `L`, `M`, `N`, `O`, `P`, `Q`, `R`, `S`, `T`, `U`, `V`, `W`, `X`, `Y`, `Z`, `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` (саме в такому порядку);
2.  всередині кожного пароля (крім 1-символьних), кожен наступний символ мусить бути строго більшим за попередній (згідно алфавіту п. 1).

Правила порівняння різних паролів не міняються (але примітка «літери менші за цифри» тепер слідує з «алфавітного порядку»).

**Частковий розв’язок на 76 балів (зі 100).**
Оскільки в умові сказано, що досить багато балів припадає на не дуже великі значення ~n~, можна писати перебір, тобто дійсно генерувати послідовно 1-й, 2-й, ... паролі аж до ~n~-го. Виявляється, при цьому не дуже важко добитися, щоб генерувалися відразу лише допустимі (згідно з умовою задачі) паролі.

Розглянемо простіший випадок. Нехай потрібно вивести послідовно пари (1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5), тобто пари з чисел від 1 до 5, щоб 2-й елемент пари завжди був строго більшим за 1-й. Це можна зробити за допомогою циклів та `if`-а, як у лівому стовпчику рис. 1. А можна, як у правому, замінити *перевірку* ~i<j~ на *задання лише потрібного* діапазону.


```pascal
for i:=1 to 5 do
    for j:= 1 to 5 do
        if i < j then
            writeln(i, ', ', j);
            
# Рис. 1. Перший спосіб генерації однієї послідовності пар
```

```pascal
for i:=1 to 4 do
    for j:=i+1 do
        writeln(i, ', ', j);
        
# Рис. 2. Другий спосіб генерації однієї послідовності пар
```

Для 2-х вкладених циклів це дрібна оптимізація (≈ удвічі). Але якщо застосувати ту саму ідею до циклів більшої вкладеності, пришвидшення істотне: для п'яти вкладених циклів ≈ сотні разів, для десяти --- ≈ мільйони. (Доведення потребує знань комбінаторики, але не дуже глибоких, тож пропонується як вправа. До того ж, писати програму можна й без доведення...)

Приклад такого розв’язку --- `Xg6sKT`. Це зовсім не взірець красоти й лаконічності. У ньому легко допустити і важко шукати технічні помилки. Але він все ж набирає чимало балів.

**Повний (100%) розв’язок.**
Перш за все, загальна кількість ~k~-символьних паролів рівна ~C(36, k)~, де ~C(n,k)~, воно ж ~C_n^k~ --- кількість *сполучень* (рос. *сочетания*, англ. *combinations*) з ~n~ по ~k~. Це так, бо з 36 символів вибираються ~k~ різних, і одні й ті самі вибрані символи не можна переставляти місцями, бо дозволений лише порядок за зростанням (у алфавіті `A`, `B`, ..., `Z`, `0`, `1`, ..., `9`).

Так що почнемо розв’язок з того, що взнаємо довжину (кількість символів) шуканого пароля і його номер *серед паролів цієї довжини*.

*   Наприклад, прочитали у вхідних даних 2015.
*   Кіль-ть 1-символьних паролів ~C(36,1)=36~, ~36<2015~ --- отже, у паролі більше одного символу, й номер серед (більш-ніж-1)-символьних ~2015-36=1979~.
*   Кіль-ть 2-символьних паролів ~C(36,2)=630~, ~630<1979~ --- отже, у паролі більше двох символів, і номер серед (більш-ніж-2)-символьних ~1979-630=1349~.
*   Кіль-ть 3-символьних паролів ~C(36,3)=7140~, ~7140>1349~ --- отже, пароль 3-символьний, і його номер серед 3-символьних рівний 1349.

Узнавши довжину пароля та його номер серед паролів відповідної довжини, починаємо взнавати цей пароль символ за символом, зліва направо --- на тій підставі, що для кожного можливого початку можна взнавати (засобами комбінаторики) кількість паролів з таким початком і знову приймати рішення, чи цей початок треба пропустити (всі паролі з таким початком мають менші номери), чи використати (потрібний номер якраз потрапляє у діапазон).

*   Продовжимо аналіз того самого прикладу (вхідний номер 2015, раніше з’ясовано, що його номер серед 3-символьних рівний 1349).
*   Кіль-ть 3-символьних паролів, що починаються з `A`, рівна ~C(35,2) = 595~, бо продовження 2-символьне з 35 символів (від `B` до `9`). ~1349>595~ --- отже, початок паролю не `A`, а якийсь подальший символ, і номер серед тих подальших ~1349-595=754~.
*   Кіль-ть 3-символьних паролів, що починаються з `B`, рівна ~C(34,2) = 561~, бо продовження 2-символьне з 34 символів (від `C` до `9`). ~754>561~ --- отже, початок паролю не `B`, а якийсь подальший символ, і номер серед тих подальших ~754-561=193~.
*   Кіль-ть 3-символьних паролів, що починаються з `C`, рівна ~C(33,2) = 528~, бо продовження 2-символьне з 33 символів (від `D` до `9`). ~193<528~ --- отже, початок паролю якраз-таки `C`, і його номер серед 3-символьних, що починаються з `C` --- теж 193.
    *   Далі відбувається аналогічний підбір наступного символу:
    *   Кіль-ть 3-символьних паролів, що починаються з `CD`, рівна ~C(32,1)=32~, бо лишається дописати один символ, від `E` до `9`. ~193>32~ --- отже, 2-га літера не `D`, а якийсь подальший символ, і номер серед тих подальших ~193-32=161~.
    *   І так далі.
    *   Продовживши аналогічні міркування, отримаємо, що шуканий пароль 16-й серед тих, що починаються з `CJ`, а оскільки після `J` можуть іти лише символи, починаючи з `K`, то цим 16-м буде `Z`.
*   Остаточно, 2015-й пароль має вигляд `CJZ`.

Ці пояснення займають багато місця, але лише тому, що наведено приклад. Правильна реалізація цього комбінаторного алгоритму працює дуже швидко, вкладаючись у секунду з величезним запасом. Адже всього-то треба:

1.  Познаходити ~C(n,k)~, наприклад, усі зразу із проміжку ~0 < k < n < 36~ за допомогою трикутника Паскаля;
2.  Знайти кількість символів у паролі --- віднімати циклом ~C(36,1)~, ~C(36,2)~, ...; якби дійшли до ~C(36,36))~, а номер після усіх віднімань все ще лишався надто великим --- це означало б, що пароля вказаних вигляду і номера взагалі не існує. Але такого не буде, бо паролів (~2^{36}-1~) все-таки більше, чим ~n<10^{10}~. Значить --- тут не більш як 36 порівнянь та віднімань;
3.  Для кожної позиції (1-й символ, 2-й, ...) запустити цикл, щоб знайти конкретне значення відповідного символу --- теж не багато, бо і позицій, і значень символів не більше 36.

Від вираження асимптотичної оцінки складності алгоритму типовим чином (через ~n~ зі вхідних даних) утримаємось, бо надто багато залежить від розміру алфавіту, а залежність часу роботи від значення ~n~ заплутана. *Якби* розмір алфавіту був змінним (і при цьому не з'являлася «довга» арифметика), можна було б говорити про час роботи ~O(A^2)~, де ~A~ --- розмір алфавіту.﻿
