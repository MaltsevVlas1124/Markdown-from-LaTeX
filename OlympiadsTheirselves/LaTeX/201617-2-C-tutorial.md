## Знаходження 1-ї відповіді.
З&nbsp;"при сповзанні кубики ніколи не летять, перекидаючись" виплива́є, що&nbsp;вони лише зміщуються на&nbsp;правіші позиції, тобто ніякий кубик не міняє своєї висоти́. Кубикам, що&nbsp;лежать на&nbsp;дні, сповзати нема куди (з&nbsp;~1 < a_j~ слідує, що&nbsp;увесь нижній ряд зайнятий). Будь-який інший кубик на&nbsp;початку лежав на&nbsp;нижчому, а&nbsp;не висів у&nbsp;повітрі; от і&nbsp;при нахилі він або сповзає разом із нижчим, на&nbsp;якому лежить, або, якщо той нижчий впирається у&nbsp;правого сусіда, а&nbsp;сам поточний ні, то поточний зсувається праворуч, на&nbsp;нового нижчого, теж не змінюючи своєї висоти́. (Ситуація, що&nbsp;поточний впирається у&nbsp;правого сусіда, а&nbsp;нижчий ні, неможлива, бо для цього треба, щоб кубик праворуч до&nbsp;того вже висів у&nbsp;повітрі, що&nbsp;неможливо.)

Звідси, для простого часткового випадку, коли стовпчиків лише два і&nbsp;~a_1 > a_2~ (на&nbsp;початку 1-й стовпчик був вищим за&nbsp;2-й), верхні ~a_1 - a_2~&nbsp;кубиків сповзають з&nbsp;1-го на&nbsp;2-й, після чого вже 1-й стовпчик виявляється нижчим (*тієї ж* висоти́ ~a_2~, якої раніше був 2-й), а&nbsp;2-й вищим (висоти́ ~a_1~). Якщо ж на&nbsp;початку ~a_1 < a_2~, взагалі нічого не змінюється. В обох випадках, *перший рядок відповіді являє собою відсортовану послідовність висот зі вхідних даних*.

Якщо стовпчиків не два, а&nbsp;більше, то все одно кубики або не рухаються відносно дна, або зсуваються послідовно на&nbsp;наразі сусідній стовпчик (можливо, багатократно, але кожен з&nbsp;цих багатьох разів — на&nbsp;сусідній), і&nbsp;завжди призводить до&nbsp;того, що&nbsp;в&nbsp;кожній парі сусідніх стовпчиків ви́соти чи&nbsp;то лишаються які були, чи&nbsp;то обмінюються місцями (більша йде праворуч, менша ліворуч). Так що&nbsp;всі сповзання разом узяті, хоч і&nbsp;можуть відбуватися в&nbsp;іншому порядку, ніж сортування, в&nbsp;результаті дають відсортовану послідовність висот.

Отже, 1-й рядок відповіді зручно отримати, не моделюючи весь процес сповзань, а&nbsp;застосувавши ефективний алгоритм сортування (див. далі).

## Знаходження 2-ї відповіді.
Щоб не плутати вже відсортовану (для 1-ї відповіді) послідовність висот із початковою, будемо в&nbsp;цьому тексті називати відсортовану послідовність ~h_1~, ~h_2~, ..., ~h_N~ (хоча технічно це той самий масив у&nbsp;різні моменти часу).
Усі рядки з&nbsp;№1 по&nbsp;№~h_1~ заповнені повністю (бо ~h_1~ — мімíнальна з&nbsp;усіх висот), тобто можна вивести у&nbsp;2-й рядок відповіді ~h_1~&nbsp;штук значень ~N~ (де ~N~ — загальна кількість стовпчиків). Потім ~h_2 - h_1~&nbsp;рядків містять ~N - 1~&nbsp;кубиків, причому це так і&nbsp;при ~h_2 > h_1~ (тоді у&nbsp;кожному з&nbsp;рядків від №~(h_1 + 1)~ до&nbsp;№~h_2~ включно після зсувів рівно один крайній лівий стовпчик вільний, а&nbsp;решта зайняті, бо рівно один крайній лівий стовпчик має строго меншу висоту, а&nbsp;решта більшу-або-рівну), і&nbsp;при ~h_2 = h_1~ (тоді у&nbsp;відповідь не потрапляє жодне значення ~N - 1~, і&nbsp;це теж правильно, бо тоді на&nbsp;всіх висотах по&nbsp;~h_1~ включно по&nbsp;~N~ кубиків, а&nbsp;починаючи з&nbsp;висоти́ ~h_1 + 1~ строго менше ніж ~N - 1~ кубик). Аналогічне міркування можна повторити багатократно й&nbsp;отримати, що&nbsp;далі є рівно ~h_3 - h_2~&nbsp;значень ~N - 2~, рівно ~h_4 - h_3~&nbsp;значень ~N - 3~, ..., рівно ~h_N - h_{N-1}~&nbsp;значень ~1~.

## Асимптотична складність
визначається, в&nbsp;основному, використаним сортуванням. Бульбашка, вибір та&nbsp;інші прості методи сортування мають складність ~O(N^2)~ і&nbsp;не мають шансів укластися в&nbsp;обмеження часу на&nbsp;всіх тестах. Сортування злиттям, сортування Хоара (QuickSort) та&nbsp;пірамідальне сортування мають складність ~Θ(N log N)~ що&nbsp;при ~N < 123456~ цілком прийнятно.

(Хто не знає цих алгоритмів — знайдіть у&nbsp;літературі або в&nbsp;Інтернеті; сортування Хоара, хоч і&nbsp;називається QuickSort, насправді має складність ~Θ(N log N)~ не завжди, а&nbsp;тільки у&nbsp;більшості випадків, іноді погіршуючись аж до&nbsp;~N^2~; ця задача не містить спеціальних анти-quick-sort-івських тестів, тому саме тут це не важливо, але для розуміння загальної картини варто це знати.)

Можна й&nbsp;скористатися бібліотечним сортуванням, якщо таке є (функція `sort` бібліотеки `algorithm` мови C++, або метод `Arrays.sort` мови Java, або метод `sort` пітонівського `list`-а, тощо), не розбираючись, як&nbsp;це влаштовано всередині. Так робити не заборонено. Інша справа, що&nbsp;знання про те, як&nbsp;насправді влаштовані ці підпрограми, можуть знадобитися в&nbsp;якихось інших ситуаціях.

## Альтернативний розв'язок: асимптотика ~Θ(N + max a_j)~ та отримання 2-ї відповіді навіть без 1-ї.
В&nbsp;цій задачі можна застосувати *сортування підрахунком* (*counting sort*). Його суть така: заводиться масив `num`, íндекси якого відповідають висóтам, а&nbsp;значення — *кількості* стовпчиків відповідної висоти́ (технічно — усі елементи ініціалізуються нулями, а&nbsp;при читанні вхідних даних, замість `read(a[i])`, робляться дії `read(a); num[a]:=num[a]+1`).

1-а відповідь (саме сортування підрахунком) формується як&nbsp;"`num[1]` штук одиниць, потім `num[2]` штук двійок, тощо" (до речі, це дещо схоже на&nbsp;формування 2-го рядка відповіді раніше розглянутим способом, так що&nbsp;знання сортування підрахунком може бути корисним як&nbsp;для того, щоб використати його тут, так і&nbsp;для придумування вищезгаданого знаходження 2-ї відповіді 1-м способом).

А&nbsp;2-у відповідь можна отримати так: сформувати на&nbsp;основі масиву `num` масив `num_gr_eq`, тобто "кількість більших-або-рівних" (наприклад, способом, показаним у&nbsp;коді праворуч), і&nbsp;просто вивести усі елементи `num_gr_eq` чи&nbsp;то до кінця, чи&nbsp;то доки вони ненульові.
```text
num_gr_eq[max_a_j]:=num[max_a_j];
for j:=max_a_j-1 downto 1 do
    num_gr_eq[j]:=num_gr_eq[j+1]+num[j];
```

Легко бачити, що&nbsp;асимптотика такого підходу ~Θ(N + max a_j)~, що&nbsp;формально краще за&nbsp;~Θ(N log N)~. Втім, на&nbsp;практиці різниця між ними невелика й&nbsp;у значній мірі нівелюється часом читання вхідних даних. Так що&nbsp;питання більше в&nbsp;тому, що&nbsp;зручніше писати. Якщо є зручне готове бібліотечне сортування — мабуть, краще використати його і&nbsp;знаходження 2-ї відповіді через 1-у.
