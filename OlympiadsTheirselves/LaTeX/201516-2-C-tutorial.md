## Примітки
Задача має багато спільного з задачею «Генератор паролів». Тут теж варто знайти, скільки всього можливих послідовностей починається з `A` і або побачити, що задане у вхідних даних ~n~ < цієї кількості (тоді послідовність-відповідь починається з `A` і слід продовжити підбирати літери на подальших позиціях), або, у протилежному випадку, слід відняти з заданого у вхідних даних ~n~ кількість цих послідовностей (що починаються з `A`) і зробити те саме щодо послідовностей, що починаються з `B`, `C`, `D`.

Тож треба знаходити кількість послідовностей, що починаються з такої-то послідовності літер (і тому відомо, з яких літер у яких кількостях складаються можливі продовження). Виборки, де всі елементи розставляють усіма можливими порядками, не змінюючи набір цих елементів, називають *перестановками* (*permutations*). Якщо у наборі елементів, які переставляють, є однакові (наприклад, `ABCB`, причому, якщо обміняти місцями одне `B` з іншим `B`, це вважається тим самим способом), то виборки називають *перестановками з повтореннями*, і їх кількість може бути виражена як

$$\overline{P}(k_1, k_2, \dots, k_n) = \frac{(k_1+k_2+\dots+k_n)!}{k_1!\cdot{}k_2!\cdot\ldots\cdot{}k_n!}$$

де `!` означає факторіал, ~k_1~, ~k_2~, ..., ~k_n~ --- кількості елементів кожного типу. (Звідки береться ця формула? Пропонуємо знайти у літературі чи Інтернеті; при розв'язуванні задачі це не потрібне, досить знати саму формулу; але виведення і допомагає її запам'ятати, і може бути корисним у інших ситуаціях.)
В цій задачі, формула набуває вигляду
~\overline{P}(a, b, c, d) = \frac{(a+b+c+d)!}{a!\cdot{}b!\cdot{}c!\cdot{}d!}~.

Лишається тільки поєднати розглянуті міркування. Зробіть це самостійно. А для контролю правильності розглянемо приклад
~a = 1~,
~b = 2~,
~c = 3~,
~d = 4~,
~n = 2015~.

При початку на `A`, можливих продовжень
~\overline{P}(0,2,3,4)~, бо якщо взяти на першу позицію `A`, на подальші позиції не лишається жодної `A`,}
~b = 2~ штук `B`,
~c = 3~ штук `C`,
~d = 4~ штук `D`.
~\frac{(0+2+3+4)!}{0!\cdot2!\cdot3!\cdot4!} = 1260 < 2015~, тобто відповідь починається не на `A`, а на одну з подальших літер, і номер відповіді серед тих подальших дорівнює ~2015 - 1260 = 755~.

При початку на `B`, можливих продовжень
~\overline{P}(1,1,3,4)~, бо якщо взяти на першу позицію `B`, на подальші позиції лишається
~a = 1~ штука `A`,
~b = 1~ штука `B`,
~c = 3~ штук `C`,
~d = 4~ штук `D`.
~\frac{(1+1+3+4)!}{1!\cdot1!\cdot3!\cdot4!} = 2520 > 755~, тобто відповідь починається якраз на `B`, і треба шукати подальші літери.

При початку на `BA`, можливих продовжень
~\overline{P}(0,1,3,4)~, бо якщо взяти на перші дві позиції `BA`, на подальші позиції лишається
~a = 0~ штук `A`,
~b = 1~ штука `B`,
~c = 3~ штук `C`,
~d = 4~ штук `D`.
~\frac{(0+1+3+4)!}{0!\cdot1!\cdot3!\cdot4!} = 280 < 755~, тобто відповідь починається не на `BA`, а має на другій позиції одну з подальших літер, і номер відповіді серед тих подальших дорівнює ~755 - 280 = 475~.

При початку на `BB`, можливих продовжень
~\overline{P}(1,0,3,4) = 280 < 475~, тож відповідь починається не на `BB`, а має на другій позиції одну з подальших літер, і номер серед тих подальших рівний ~475 - 280 = 195~.

При початку `BС`, можливих продовжень
~\overline{P}(1,1,2,4) = \frac{(1+1+2+4)!}{1!\cdot1!\cdot2!\cdot4!} = 840 > 195~, тож відповідь починається якраз на `BC'.

При початку `BСA`, можливих продовжень
~\overline{P}(0,1,2,4) = \frac{(0+1+2+4)!}{0!\cdot1!\cdot2!\cdot4!} = 105 < 195~, тож відповідь має на третій позиції одну з подальших літер, номер серед подальших ~195 - 105 = 90~.

При початку `BСB`, можливих продовжень
~\overline{P}(1,0,2,4) = 105 > 90~, тож відповідь починається на `BCB'.

При початку `BСBA`, можливих продовжень
~\overline{P}(0,0,2,4) = \frac{(0+0+2+4)!}{0!\cdot0!\cdot2!\cdot4!} = 15 < 90~, тож відповідь має на четвертій позиції одну з подальших літер, номер серед подальших ~90 - 15 = 75~.

Тепер треба правильно врахувати (наприклад, передбачити `if` для таких ситуацій), що літер `B` спочатку було лише ~b=2~ й тому початок `BСBB` взагалі неможливий (кількість = 0) і тому треба продовжити, перейшовши до `BСBC`.

І так далі. Остаточна відповідь --- `BCBDDCDCAD`.

У тексті це займає багато місця, але виконується такий алгоритм дуже швидко --- сумарна кількість обчислень формули ~\overline{P}(\dots)~ не перевищує ~4 \times (a + b + c + d)~ (бо кількість розрядів ~a + b + c + d~, у кожному пробуються, щонайбільше,
`A`, `B`,
`C`, `D`), тож загальна кількість дій може бути виражена як ~O((a + b + c + d)^2)~ навіть при не найкращій реалізації самої формули, яка щоразу заново переобчислює факторіали; якщо ж зберігати готові факторіали, можна оптимізувати усю разом узяту програму до ~\Theta(a + b + c + d)~ (втім, при настільки малих ~a~, ~b~, ~c~, ~d~ це несуттєво).

### Як легко й просто набрати 60% балів (лише C++).
У бібліотеці `algorithm` мови C++ є функція `next_permutation`, яка дозволяє послідовно перебирати перестановки у порядку зростання (що й треба у цій задачі), і яка правильно працює з будь-якими перестановками (з повтореннями чи без). Так що можна сформувати `string s` зі значенням A...A (a штук) B...B (b штук) C...C (c штук) D...D (d штук) і ~n-1~ разів застосувати `next_permutation(s.begin(), s.end());`. Складність такого алгоритму становить ~\Theta(n)~ (причому, `next_permutation`, хоч і має амортизовану складність ~\Theta(1)~, не дуже швидка), тож він ніяк не може бути досить ефективним при ~n \approx \overline{P}(5,5,5,5) = \frac{20!}{5!\cdot5!\cdot5!\cdot5!} \approx 1.173 \cdot 10^{10}~.
В умові задачі нема розбаловки, тож не ясно, що це саме 60%; але очевидно, що якісь бали мусять бути.

### А інші?
Автори збірника не впевнені, чи достатньо дослідили бібліотеки інших мов програмування, але хоч трохи схожі засоби вдалося знайти лише у Python (клас `permutations` модуля `itertools`). Причому, цей клас не так, як треба, працює з повтореннями елементів, тож невідомо, як використати його краще, ніж `a = list(set(permutations(s)))`, `a.sort()`, тобто спочатку згенерувати геть усі перестановки (звичайні), потім використати `set`, щоб позбутися повторень, потім перетворити у масив (`list`) і відсортувати. Все це, звісно, працює *набагато* довше, головним чином, тому, що на проміжному етапі генеруються перестановки без повторень, а їх може бути значно
більше: наприклад, при ~a = b = 4~, ~c = d = 3~ маємо ~14! \approx 8.7 \cdot 10^{10}~ (причому їх треба ще й одночасно тримати у пам'яті) проти ~\frac{14!}{4!4!3!3!} \approx 4.2 \cdot 10^6~ (що для комп'ютера небагато, причому вони перебираються одна за одною, не займаючи багато пам'яті).
Цей спосіб набирає 40% балів.

### А ще інші?
На жаль, для ще інших мов програмування важко запропонувати простий спосіб набрати навіть таку частину балів.
Це сумно, але:
(1) 100%-й алгоритм можна написати будь-якою з доступних мов програмування;
(2) нікому з учасників не заборонялося вчити й використовувати C++.

Писати власний аналог `next_permutation` не доцільно, бо потребує майже стільки ж зусиль, як ефективний розв'язок початкової задачі, а принести може, щонайбільше, ті ж 60% балів. Тим не менш, кому цікаво, може знайти у літературі чи Інтернеті *алгоритми генерації перестановок*.
Є кілька різних класичних алгоритмів такої генерації. І *одні* з них (які визначають, що поміняти у поточній перестановці, щоб перейти до наступної) оптимізовані під відносно швидшу організацію перебору усіх підряд перестановок (у `next_permutation` саме такий). А *інші* (зокрема, рекурсивні) дозволяють вписування додаткових умов, щоб пропускати непотрібні. Говорячи про цю задачу, такі модифікації можна кінець кінцем перетворити до рекурсивної версії рекомендованого способу.