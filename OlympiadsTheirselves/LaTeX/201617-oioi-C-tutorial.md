Перш за&nbsp;все, рекомендуємо перечитати все, що&nbsp;сказано на&nbsp;стор. "about-wall-tle-for-interactive-tasks" про те, як&nbsp;неправильні розв'язки інтерактивних задач провокують вердикт "Wall Time Limit Exceeded". Переходячи ж до&nbsp;суті конкретно цієї задачі, наведена у&nbsp;прикладі "стратегія" фактично такою не є. Хоч за&nbsp;її допомогою і&nbsp;зручно вгадати 17, але як&nbsp;щодо 91? А&nbsp;щодо 987987981?

Насправді це широковідома класична задача, яку слід розв'язувати так званим *бінарним пошуком* (він же&nbsp;*бінпошук*, він же&nbsp;*двійковий пошук*, він же&nbsp;*дихотомія*). Коротко суть описана на&nbsp;стор. "omnipresent-numbers-binsearch", детальніше рекомендуємо знайти в&nbsp;Інтернеті або літературі. До&nbsp;речі, на&nbsp;цьому ж сайті `ejudge.ckipo.edu.ua` є змагання 53 "Дорішування теми Бінарний та&nbsp;тернарний пошуки Школи Бобра (23.10.2016)", в&nbsp;якому є і&nbsp;теоретичні матеріали, і&nbsp;комплект задач.

Так що&nbsp;наведемо, без детальних пояснень, посилання на&nbsp;готовий розв'язок [IdeOne C5i8Wc](https://ideone.com/C5i8Wc) та&nbsp;зауваження щодо деяких тонкостей.

Нехай межі проміжку називаються `left` та&nbsp;`right`. Є два поширені способи вибирати середину проміжку `mid`:
(1) `mid := (left+right) div 2`;
(2) `mid := left + (right-left) div 2`.

Для знакових `left` та&nbsp;`right`, ***кожен*** з&nbsp;них може призвести до&nbsp;переповнень (див. також стор. "overflow-example"). Тільки `(left + right) div 2` переповнюється тоді, коли обидва значення `left` та&nbsp;`right` дуже великі за&nbsp;модулем і&nbsp;одного знаку, а&nbsp;`left + (right - left) div 2` — коли `left` дуже велике за&nbsp;модулем від'ємне, а&nbsp;`right` дуже велике додатнє. Так що&nbsp;треба або рахувати у&nbsp;ширшому типі, або робити розгалуження, щоб вибрати ту з&nbsp;формул, яка краща для поточних значень `left` та&nbsp;`right`.

Ще один тонкий момент — уникнути зациклювань. Вони можливі, зокрема (але не тільки) якщо при отриманні від суперника вердикту `+` робиться присвоєння `left:=mid`. Такий алгоритм успішно звужує проміжок від величезного до&nbsp;невеликого, але при, наприклад, `left=3`, `right=4` і&nbsp;загаданому числі 4 одні й&nbsp;ті самі присвоєння `mid := (left+right) div 2` ~= (3+4) div 2 = 3~, `left:=mid` ~=3~ повторюватимуться вічно (ну, або доки програму не завершать за&nbsp;те, що&nbsp;вона за&nbsp;50&nbsp;запитів так і&nbsp;не добилася вердикту `=`). Конкретно для цієї задачі зручно гарантовано позбутися зациклювань за&nbsp;рахунок того, що&nbsp;при вердикті `+` робити `left:=mid+1`, а&nbsp;при `-` робити `right:=mid-1`. Тобто, зменшувати проміжок одночасно і&nbsp;за&nbsp;рахунок присвоєння межі значення середини, і&nbsp;за&nbsp;рахунок виключення самої цієї середини, яка теж не є шуканою відповіддю (бо не отримала вердикту `=`). Але, на&nbsp;жаль, при багатьох інших застосуваннях бінпошуку така ідея просто неправильна.

Ще одна тонкість — якщо сума `left+right` одночасно і&nbsp;непарна, і&nbsp;від'ємна, вищезгадані формули `mid := (left+right) div 2` та&nbsp;`mid := left + (right-left) div 2` не взаємозамінні навіть при відсутності переповнень. Перша з&nbsp;них заокруглює до&nbsp;нуля, друга — у&nbsp;менший бік. Зокрема, якщо при вердикті `+` робити `left:=mid+1`, а&nbsp;при `-` робити `right:=mid` (без —1), то перша з&nbsp;них може зациклити алгоритм, а&nbsp;друга не містить такого ризику.
