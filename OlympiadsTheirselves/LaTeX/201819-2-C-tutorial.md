Чому очевидний підхід набирає так мало балів?
Справді обчислювати сам факторіал і&nbsp;шукати його останню ненульову цифру — формально правильно, але набирає дуже мало балів. Факторіал дуже швидко зростає: ~8!=40320~ вже не&nbsp;поміщається у&nbsp;16-бітовий знаковий цілий тип, ~13!=6227020800~ — у&nbsp;32-бітовий, ~21!=51090942171709440000~ — у&nbsp;64-бітовий. Так що&nbsp;для мов програмування, в&nbsp;яких найбільшим цілочисельним типом є 64-бітовий, цей підхід правильний лише для ~N<20~.

Межу ~N<20~ можна збільшити до&nbsp;~N<23~, якщо щоразу, коли додається нуль наприкінці, тут же відкидати його: ~1 \xrightarrow{\*2} 2 \xrightarrow{\*3} 6 \xrightarrow{\*4} 24 \xrightarrow[/10]{\*5} 12 \xrightarrow{\*6} 72 \xrightarrow{\*7} 504 \xrightarrow{\*8} 4032 \xrightarrow{\*9} 36288 \xrightarrow[/10]{\*10} 36288 \xrightarrow{\*11} \dots~

Деякі з&nbsp;дозволених на&nbsp;олімпіаді мов програмування мають вбудовану довгу арифметику, тобто вміють працювати зі значно більшими цілими числами: Python — просто; Java — через бібліотечний тип `BigInteger`. (C# теж має тип `BigInteger`, але там усе сумніше, бо засоби, якими `BigInteger` підключається на&nbsp;локальному Windows-комп'ютері, не&nbsp;працюють на&nbsp;Linux-сервері ejudge, і&nbsp;авторам збірника невідомо ні як&nbsp;їх підключити там, ні, навіть, чи&nbsp;можливо це взагалі.) Використання довгої арифметики (байдуже, готової чи&nbsp;написаної власноруч) дозволяє дещо розширити діапазон ~N~, але недостатньо: з&nbsp;нею повинні проходити не&nbsp;лише всі тести з&nbsp;~N<23~, а&nbsp;й усі блоки тестів з&nbsp;~N<555~. А&nbsp;подальші блоки повинні не&nbsp;проходити: наприклад, 50000! має понад 200&nbsp;тис. десяткових цифр, так що&nbsp;обчислення не&nbsp;мають шансів поміститися в&nbsp;обмеження за&nbsp;часом.

То що&nbsp;ж робити?
Раз питають *лише останню* ненульову цифру, *нема потреби* обчислювати та&nbsp;зберігати *всі* цифри факторіалів. Але це й&nbsp;*не* класична модульна арифметика (в&nbsp;якій досить зберігати лише останню цифру), бо питають *останню ненульову*, кількість нулів наприкінці ~N!~ зі зростанням ~N~ час від часу збільшується, й&nbsp;потрібний розряд час від часу зсувається: при ~1<N<4~ це розряд одиниць (остання цифра), при ~5<N<9~ — розряд десятків (передостання цифра), тощо.

Спробуємо з'ясувати, коли скільки нулів додається наприкінці факторіалу. Важливо, що&nbsp;розглядаємо саме десяткову систему числення (~10=2^1\cdot5^1~) і&nbsp;саме ~N! = 1\times2\times\dots\times N~. Яке б не&nbsp;було число вигляду ~5^{a}\times b~, число ~2^{a}\times b~ (при тих самих додатних ~a~, ~b~) існує і&nbsp;менше ~5^{a}\times b~. Так що, при послідовному домноженні ~(1\times2\times\dots\times(N-1))\times N~, на&nbsp;кожну п'ятірку, скільки б їх не&nbsp;було в&nbsp;розкладенні ~N~, «вже чекає» відповідна кількість двійок, наявних у&nbsp;розкладенні ~(N-1)!~ і&nbsp;ще не&nbsp;використаних іншими п'ятірками. Так що&nbsp;кожне число, яке можна подати як&nbsp;~5^{a}\times b~ (де ~b~ не&nbsp;кратне 5) додає наприкінці факторіала рівно ~a~ нулів.

Спосіб № 1 отримати повні бали (крім Python).
Оскільки ~5^9=1953125<2018019<9765625=5^{10}~, за&nbsp;одне домноження з'являтиметься щонайбільше дев'ять нулів. І&nbsp;ніщо не&nbsp;заважає поєднати такі ідеї: (1) відкидати нулі наприкінці, як&nbsp;тільки вони з'являються; (2) зберігати (у&nbsp;64-бітовій змінній) останні 10–12 десяткових цифр. Якось так: ~1 \xrightarrow{\*2} 2 \xrightarrow{\*3} 6 \xrightarrow{\*4} 24 \xrightarrow[/10]{\*5} 12 \xrightarrow{\*6} 72 \xrightarrow{\*7} 504 \xrightarrow{\*8} 4032 \xrightarrow{\*9} 36288 \xrightarrow[/10]{\*10} 36288 \xrightarrow{\*11} 399168 \xrightarrow{\*12} 4790016 \xrightarrow{\*13} 62270208 \xrightarrow{\*14} 871782912 \xrightarrow[/10]{\*15} 1307674368 \xrightarrow[\bmod10^{10}]{\*16} 922789888 \xrightarrow[\bmod10^{10}]{\*17} 5687428096 \xrightarrow[\bmod10^{10}]{\*18} 2373705728 \xrightarrow[\bmod10^{10}]{\*19} 5100408832 \xrightarrow[/10,\bmod10^{10}]{\*20} 200817664 \xrightarrow{\*21} 4217170944 \xrightarrow[\bmod10^{10}]{\*22} 2777760768 \xrightarrow[\bmod10^{10}]{\*23} 3888497664 \xrightarrow[\bmod10^{10}]{\*24} 3323943936 \xrightarrow[/100]{\*25} 830985984 \xrightarrow[\bmod10^{10}]{\*26} 1605635584 \xrightarrow[\bmod10^{10}]{\*27} \dots~
Для ~N<5^{10}~, 10–12 цифр водночас і&nbsp;досить багато, щоб не&nbsp;втратити зразу всі ненульові цифри, і&nbsp;досить мало, щоб при черговому домноженні ніколи не&nbsp;виникало переповнення 64-бітового типу.

Спосіб № 2 отримати повні бали (крім Python).
Вже відзначено, що&nbsp;класична модульна арифметика (зберігати лише останню цифру) незастосовна, бо питають останню *ненульову*, й&nbsp;потрібний розряд час від часу зсувається. Але можна помітити, що&nbsp;раз кількість нулів наприкінці визначається кількістю п'ятірок, то, прибравши з&nbsp;~N!~ відповідну кількість п'ятірок і&nbsp;таку саму кількість двійок, отримаємо якраз факторіал крім нулів наприкінці; для цього факторіала крім нулів наприкінці *можна* зберігати й&nbsp;обчислювати саму лише останню цифру.

Конкретніше, будемо при обчисленні ~1\times2\times\dots\times i\times\dots~ «виймати» з&nbsp;кожного числа всі множники 2 та&nbsp;5, і&nbsp;рахувати окремо останню цифру добутку *всього, крім* «вийнятих» двійок та&nbsp;п'ятірок, окремо різницю кількостей «вийнятих» (на&nbsp;скільки двійок більше, ніж п'ятірок). Якось так:

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 0.
    *   Множимо на&nbsp;~2=2^1\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на&nbsp;одну більше.
    *   **Новий стан:** остання цифра 1, надлишок двійок 1.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 1.
    *   Множимо на&nbsp;~3=2^0\cdot5^0\cdot3~.
    *   **Коментар:** кількості двійок та&nbsp;п'ятірок незмінні, добуток решти домножується на&nbsp;3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 1.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 1.
    *   Множимо на&nbsp;~4=2^2\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на&nbsp;дві більше.
    *   **Новий стан:** остання цифра 3, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 3.
    *   Множимо на&nbsp;~5=2^0\cdot5^1\cdot1~.
    *   **Коментар:** «зайвих» двійок стає на&nbsp;одну менше, бо одна двійка «зв'язується» п'ятіркою.
    *   **Новий стан:** остання цифра 3, надлишок двійок 2.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 2.
    *   Множимо на&nbsp;~6=2^1\cdot5^0\cdot3~.
    *   **Коментар:** і&nbsp;двійок стає на&nbsp;одну більше, і&nbsp;добуток решти домножується на&nbsp;3.
    *   **Новий стан:** остання цифра 9, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 9, надлишок двійок 3.
    *   Множимо на&nbsp;~7=2^1\cdot5^0\cdot7~.
    *   **Коментар:** кількості двійок та&nbsp;п'ятірок незмінні, добуток решти домножується на&nbsp;7, зберігаємо з&nbsp;63 лише останню цифру 3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 3.
    *   Множимо на&nbsp;~8=2^3\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на&nbsp;три більше.
    *   **Новий стан:** остання цифра 3, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 6.
    *   Множимо на&nbsp;~9=2^0\cdot5^0\cdot9~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на&nbsp;~10=2^1\cdot5^1\cdot1~.
    *   **Коментар:** додаються одна двійка й&nbsp;одна п'ятірка, *різниця* кількостей незмінна.
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на&nbsp;~11=2^0\cdot5^0\cdot11~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на&nbsp;~12=2^2\cdot5^0\cdot3~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 1, надлишок двійок 8.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 8.
    *   Множимо на&nbsp;~13=2^0\cdot5^0\cdot13~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 3, надлишок двійок 8.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 8.
    *   Множимо на&nbsp;~14=2^1\cdot5^0\cdot7~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 1, надлишок двійок 9.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 9.
    *   Множимо на&nbsp;~15=2^0\cdot5^1\cdot3~.
    *   **Коментар:** «зайвих» двійок стає на&nbsp;одну менше, бо одна двійка «зв'язується» п'ятіркою; крім того, добуток решти домножується на&nbsp;3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 8.

І&nbsp;так далі.
Дорахувавши до&nbsp;множника ~N~ (включно), знаємо останню цифру «~N!~ без двійок та&nbsp;п'ятірок» (позначимо як&nbsp;~d~) та&nbsp;кількість «вільних» (не «зв'язаних» п'ятірками) двійок (позначимо як&nbsp;~k~). Остаточна відповідь може бути виражена як&nbsp;~ (d\cdot2^k)\bmod10 = (d\cdot(2^k\bmod10))\bmod10 ~. Враховуючи, що&nbsp;~2^0=1~, ~2^1=2~, ~2^2=4~, ~2^3=8~, ~2^4=16~, ~2^5=32~, ~2^6=64~, ~2^7=128~, ~2^8=256~, ..., тобто при ~k>0~ останні цифри циклічно повторюються, велике ~k~ можна замінити на&nbsp;~(k\bmod4)+4~, що&nbsp;дає можливість обчислювати ~2^k\bmod10~ за&nbsp;~\Theta(1)~. Втім, це мало на&nbsp;що впливає, бо основний процес домножень (із «вийманням» з&nbsp;кожного числа двійок та&nbsp;п'ятірок) значно довший.

Який з&nbsp;цих способів кращий? Важко сказати. Вони обидва мають складність ~\Theta(N)~. (Може здатися, ніби для другого є ще внутрішні цикли «викидання» двійок і&nbsp;п'ятірок, які дають додатковий множник ~\log N~; але це не&nbsp;так. Наприклад, сумарну кількість ітерацій, які шукають двійки, можна виразити як&nbsp;~N\mathrm{div}2+N\mathrm{div}2^2+\dots+N\mathrm{div}2^k~, де ~k=\lfloor\log_2 N\rfloor~; див. аргументацію формули (???) на&nbsp;стор. ???. Формула суми геометричної прогресії каже, що&nbsp;ця сума менша ~N~.)
При вказаних обмеженнях, обидва ці способи гарантовано проходять усі тести (всіма доступними на&nbsp;олімпіаді мовами програмування, *крім Python*; див. наступний абзац). Теоретичний недолік першого способу — якби дозволялися значення ~N>5^{11}\approx48,8~&nbsp;млн, то 64-бітового типу вже було б недостатньо, щоб задовольнити обидві вимоги «не втратити зразу всі ненульові цифри» та&nbsp;«не утворювати переповнень»; другому ж способу цілком достатньо як&nbsp;64-бітового, так і&nbsp;навіть 32-бітового типу аж до&nbsp;~N\approx\frac{2^{31}}{9}\approx238~&nbsp;млн (але при ~N\approx10^8~ обчислення вже тривали б десятки секунд).

Навіщо скривдили Python?
Він сам себе скривдив.
Програмам усіма мовами програмування виділявся однаковий ліміт часу. Але для розрахунків, вжитих в&nbsp;обох цих способах, Python виявився значно повільнішим не&nbsp;лише за&nbsp;традиційно швидкі мови `g++` та&nbsp;`fpc`, а&nbsp;також і&nbsp;за відносно повільні `java`, `pasabc-linux` та&nbsp;`mcs`. Враховуючи цю об'єктивну і&nbsp;значну різницю швидкодії, перед туром було прийняте свідоме рішення змиритися з&nbsp;тим, що&nbsp;реалізації одного алгоритму різними мовами набирають різні бали. З&nbsp;точки зору правил та&nbsp;традицій Всеукраїнської олімпіади з&nbsp;інформатики, це погано, але в&nbsp;такого роду виключних випадках допускається. До&nbsp;того ж, у&nbsp;цій самій задачі Python дозволяв отримати бали за&nbsp;тести вигляду ~25<N<555~, пишучи «лобовий» розв'язок і&nbsp;взагалі не&nbsp;замислюючись над тим, що&nbsp;така програма використовує довгу арифметику. Учасники, що&nbsp;вміють писати лише на&nbsp;Pascal чи&nbsp;C++, такої можливості не&nbsp;мали, і&nbsp;їм це ніяк не&nbsp;компенсувалося. Тож Python виграє в&nbsp;одному, програє в&nbsp;іншому, й&nbsp;навряд чи&nbsp;було б справедливішим надавати йому додаткові переваги, збільшуючи ліміт часу. Тим паче, що&nbsp;існує ще наступний спосіб.

Спосіб № 3 отримати повні бали (включно з&nbsp;Python).
Обмеження ~N<2018019~ підбиралося під те, щоб переважною більшістю мов працювали й&nbsp;набирали повний бал способи 1–2. Але задачу *можна* розв'язати ще значно ефективніше, якщо правильно модифікувати початий у&nbsp;способі № 2 підхід «двійки компенсують п'ятірки, для решти рахуємо останню цифру».
Вважаємо гарантованим ~N>10~, бо для ~N<10~ можна написати окремий `if`, щоб рахувати «в&nbsp;лоб».
Виділимо окремо множники, кратні 5, окремо решту, причому решту розіб'ємо на&nbsp;групи згідно десятків.
Наприклад, для 37! буде так: ~ (1\times2\times3\times4\times6\times7\times8\times9)\times(5\times10)\times(11\times12\times13\times14\times16\times17\times18\times19)\times(15\times20)\times(21\times22\times23\times24\times26\times27\times28\times29)\times(25\times30)\times(31\times32\times33\times34\times36\times37)\times(35) ~.
Добуток ~ (5\times10)\times(15\times20)\times(25\times30)\times(35) ~ можна подати як&nbsp;~ ((5\cdot1)\times(5\cdot2))\times((5\cdot3)\times(5\cdot4))\times((5\cdot5)\times(5\cdot6))\times(5\cdot7) = 5^7\times7! ~.
(Важливо, що&nbsp;з кожного числа, кратного 5, виділяється рівно одна п'ятірка, навіть якщо, як&nbsp;з 25, їх можна було б виділити більше.) Так можна робити й&nbsp;при інших ~N~, отримуючи ~5^{N\mathrm{div}5}\times(N\mathrm{div}5)!~. Тобто, з&nbsp;початкової задачі для&nbsp;~N!~ можна виділити таку саму задачу для&nbsp;~(N\mathrm{div}5)!~, і&nbsp;при цьому решта множників поділені на&nbsp;більш-менш зручні групи по&nbsp;8 з&nbsp;кожного десятку (в&nbsp;останній групі, й&nbsp;лише у&nbsp;ній, може бути менше).
Тож будемо окремо заново розв'язувати всю задачу для&nbsp;~(N\mathrm{div}5)!~, і&nbsp;окремо компенсувати п'ятірки, зібрані в&nbsp;~5^{N\mathrm{div}5}~, двійками з&nbsp;решти добутків.

Тобто, ~(N\mathrm{div}5)~ двійок треба «вийняти» з&nbsp;тих решти добутків. І&nbsp;міркувати «щоб вийняти множник з&nbsp;добутку, поділимо цей добуток на&nbsp;цей множник» тут не&nbsp;можна, бо в&nbsp;модульній арифметиці це часто не&nbsp;так. Наприклад, ~26\bmod10=6=56\bmod10~, тобто з&nbsp;точки зору остач за&nbsp;модулем 10 числа 26 та&nbsp;56 однаковісінькі, але ~ \frac{26}{2}\bmod10=13\bmod10=3\ne8=28\bmod10=\frac{56}{2}\bmod10 ~.

Спробуємо компенсувати дві п'ятірки з&nbsp;~(5\times10)~ двома двійками, «вийнятими» з&nbsp;~(1\times2\times3\times4\times6\times7\times8\times9)~, дві п'ятірки з&nbsp;~(15\times20)~ двома двійками з&nbsp;~(11\times12\times13\times14\times16\times17\times18\times19)~, тощо. До&nbsp;того, що&nbsp;остання група може бути неповна, повернемося пізніше. Тим, що&nbsp;в&nbsp;кожних таких 8-множникових дужках можна знайти більше, ніж дві, двійки, знехтуємо: їх більше, але «вийматимемо» дві.

Візьмемо число, що&nbsp;закінчується цифрою 2, та&nbsp;число, що&nbsp;закінчується цифрою 4, й&nbsp;«виймемо» з&nbsp;кожного по&nbsp;одній двійці, поділивши кожне окремо на&nbsp;2 (ділимо самі числа, не&nbsp;остачі). Можуть бути рівно два випадки: або ці числа являють собою ~20k+2~ та&nbsp;~20k+4~, або ~20k+12~ та&nbsp;~20k+14~; у&nbsp;першому випадку після ділень виходить ~10k+1~ та&nbsp;~10k+2~, у&nbsp;другому ~10k+6~ та&nbsp;~10k+7~. Оскільки в&nbsp;межах цих 8-множникових дужок більше не&nbsp;треба ділень, можна вертатися до&nbsp;модульної арифметики, відкидати ~10k~ і&nbsp;казати, що&nbsp;~1\times2=2~ та&nbsp;~6\times7=42~ закінчуються на&nbsp;однакову цифру 2.
Лишається домножити це 2 на&nbsp;останні цифри решти шести множників у&nbsp;дужках (1, 3, 6, 7, 8, 9), і&nbsp;отримати, що&nbsp;остання цифра добутку (після «виймання» двох двійок) дорівнює ~ (2\cdot1\cdot3\cdot6\cdot7\cdot8\cdot9)\bmod10 = 4 ~.
Остання цифра загального добутку всіх ~N\mathrm{div}10~ штук таких дужок рівна ~4^{N\mathrm{div}10}\bmod10~. Оскільки ~4^1=4~, ~4^2=16~, ~4^3=64~, ~4^4=256~, ..., а&nbsp;розглядаємо випадок ~(N\mathrm{div}10)>1~, значення ~4^{N\mathrm{div}10}\bmod10~ можна знайти якось у&nbsp;стилі `if ((N div 10) mod 2) = 1 then a:=4 else a:=6`.

Повернемось до&nbsp;врахування того, що&nbsp;при ~N\bmod10\ne0~ існує ще остання дужка, яка рахується не&nbsp;за тими правилами, що&nbsp;решта дужок. Якщо ~1<N\bmod10<4~, то цій дужці не&nbsp;треба компенсовувати ніяку п'ятірку, можна просто перемножити в&nbsp;модульній арифметиці останні цифри; інакше кажучи, ~(N\bmod10)!\bmod10~. Якщо ж ~5<N\bmod10<9~, то треба компенсувати рівно одну п'ятірку. (Навіть якщо число останнього неповного десятку, що&nbsp;закінчується на&nbsp;5, кратне деякому ~5^k~ при більшому ~k~, то всі п'ятірки, крім однієї, перейшли у&nbsp;~(N\mathrm{div}5)!~.) Поділимо на&nbsp;2 число, що&nbsp;закінчується на&nbsp;2; можливі рівно два випадки: або воно вигляду ~20k+2~, або ~20k+12~; у&nbsp;першому отримуємо ~10k+1~, у&nbsp;другому ~10k+6~; більше ділень не&nbsp;треба, можна вертатися до&nbsp;модульної арифметики. Точно треба домножити на&nbsp;3 та&nbsp;4 (бо розглядаємо випадок ~5<N\bmod10<9~); отримуємо або ~(1\times3\times4)\bmod10=12\bmod10=2~, або ~(6\times3\times4)\bmod10=72\bmod10=2~, тобто в&nbsp;обох випадках 2. Множити на&nbsp;5 не&nbsp;треба й&nbsp;не можна, ця п'ятірка вже врахована іншими засобами.
Лишається тільки домножити в&nbsp;модульній арифметиці на&nbsp;6, 7, ..., ~N\bmod10~ (зокрема, при ~N\bmod10=5~, не&nbsp;домножувати ні на&nbsp;що).

Дії попереднього абзацу насправді рівносильні таким: «порахувати "в&nbsp;лоб" ~(N\bmod10)!~; якщо кратний 10, поділити на&nbsp;10; взяти останню цифру». Це навіть простіше писати. Але неясно, як&nbsp;строго доводити правильність цього, не&nbsp;спираючись на&nbsp;попередній абзац.

Само собою, треба помножити (в&nbsp;модульній арифметиці) результат (поза)минулого абзаца на&nbsp;раніше отриманий (рівний або 4, або 6) результат ~4^{N\mathrm{div}10}\bmod10~, а&nbsp;також домножити (в&nbsp;модульній арифметиці) цей добуток на&nbsp;~(N\mathrm{div}5)!\bmod10~, розв'язавши всю задачу заново з&nbsp;аргументом ~N\mathrm{div}5~ замість ~N~. Це повторюватиметься приблизно ~\log_5 N~ разів. Що&nbsp;й задає асимптотичну оцінку всього розв'язку ~\Theta(\log N)~, бо все інше виконується за&nbsp;~\Theta(1)~ (щось `if`-ом, щось циклом, але з&nbsp;дуже малою кількістю ітерацій). Так що&nbsp;задачу в&nbsp;принципі можна було давати і&nbsp;для значно більших ~N~. Втім, вона і&nbsp;з обмеженням ~N<2018019~ виявилася дещо заскладною для переважної більшості учасників.﻿

