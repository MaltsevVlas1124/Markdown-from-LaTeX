Чому очевидний підхід набирає так мало балів?
Справді обчислювати сам факторіал і шукати його останню ненульову цифру — формально правильно, але набирає дуже мало балів. Факторіал дуже швидко зростає: ~8!=40320~ вже не поміщається у 16-бітовий знаковий цілий тип, ~13!=6227020800~ — у 32-бітовий, ~21!=51090942171709440000~ — у 64-бітовий. Так що для мов програмування, в яких найбільшим цілочисельним типом є 64-бітовий, цей підхід правильний лише для ~N<20~.

Межу ~N<20~ можна збільшити до ~N<23~, якщо щоразу, коли додається нуль наприкінці, тут же відкидати його: ~1 \xrightarrow{\*2} 2 \xrightarrow{\*3} 6 \xrightarrow{\*4} 24 \xrightarrow[/10]{\*5} 12 \xrightarrow{\*6} 72 \xrightarrow{\*7} 504 \xrightarrow{\*8} 4032 \xrightarrow{\*9} 36288 \xrightarrow[/10]{\*10} 36288 \xrightarrow{\*11} \dots~

Деякі з дозволених на олімпіаді мов програмування мають вбудовану довгу арифметику, тобто вміють працювати зі значно більшими цілими числами: Python — просто; Java — через бібліотечний тип `BigInteger`. (C# теж має тип `BigInteger`, але там усе сумніше, бо засоби, якими `BigInteger` підключається на локальному Windows-комп'ютері, не працюють на Linux-сервері ejudge, і авторам збірника невідомо ні як їх підключити там, ні, навіть, чи можливо це взагалі.) Використання довгої арифметики (байдуже, готової чи написаної власноруч) дозволяє дещо розширити діапазон ~N~, але недостатньо: з нею повинні проходити не лише всі тести з ~N<23~, а й усі блоки тестів з ~N<555~. А подальші блоки повинні не проходити: наприклад, 50000! має понад 200 тис. десяткових цифр, так що обчислення не мають шансів поміститися в обмеження за часом.

То що ж робити?
Раз питають *лише останню* ненульову цифру, *нема потреби* обчислювати та зберігати *всі* цифри факторіалів. Але це й *не* класична модульна арифметика (в якій досить зберігати лише останню цифру), бо питають *останню ненульову*, кількість нулів наприкінці ~N!~ зі зростанням ~N~ час від часу збільшується, й потрібний розряд час від часу зсувається: при ~1<N<4~ це розряд одиниць (остання цифра), при ~5<N<9~ — розряд десятків (передостання цифра), тощо.

Спробуємо з'ясувати, коли скільки нулів додається наприкінці факторіалу. Важливо, що розглядаємо саме десяткову систему числення (~10=2^1\cdot5^1~) і саме ~N! = 1\times2\times\dots\times N~. Яке б не було число вигляду ~5^{a}\times b~, число ~2^{a}\times b~ (при тих самих додатних ~a~, ~b~) існує і менше ~5^{a}\times b~. Так що, при послідовному домноженні ~(1\times2\times\dots\times(N-1))\times N~, на кожну п'ятірку, скільки б їх не було в розкладенні ~N~, «вже чекає» відповідна кількість двійок, наявних у розкладенні ~(N-1)!~ і ще не використаних іншими п'ятірками. Так що кожне число, яке можна подати як ~5^{a}\times b~ (де ~b~ не кратне 5) додає наприкінці факторіала рівно ~a~ нулів.

Спосіб № 1 отримати повні бали (крім Python).
Оскільки ~5^9=1953125<2018019<9765625=5^{10}~, за одне домноження з'являтиметься щонайбільше дев'ять нулів. І ніщо не заважає поєднати такі ідеї: (1) відкидати нулі наприкінці, як тільки вони з'являються; (2) зберігати (у 64-бітовій змінній) останні 10–12 десяткових цифр. Якось так: ~1 \xrightarrow{\*2} 2 \xrightarrow{\*3} 6 \xrightarrow{\*4} 24 \xrightarrow[/10]{\*5} 12 \xrightarrow{\*6} 72 \xrightarrow{\*7} 504 \xrightarrow{\*8} 4032 \xrightarrow{\*9} 36288 \xrightarrow[/10]{\*10} 36288 \xrightarrow{\*11} 399168 \xrightarrow{\*12} 4790016 \xrightarrow{\*13} 62270208 \xrightarrow{\*14} 871782912 \xrightarrow[/10]{\*15} 1307674368 \xrightarrow[\bmod10^{10}]{\*16} 922789888 \xrightarrow[\bmod10^{10}]{\*17} 5687428096 \xrightarrow[\bmod10^{10}]{\*18} 2373705728 \xrightarrow[\bmod10^{10}]{\*19} 5100408832 \xrightarrow[/10,\bmod10^{10}]{\*20} 200817664 \xrightarrow{\*21} 4217170944 \xrightarrow[\bmod10^{10}]{\*22} 2777760768 \xrightarrow[\bmod10^{10}]{\*23} 3888497664 \xrightarrow[\bmod10^{10}]{\*24} 3323943936 \xrightarrow[/100]{\*25} 830985984 \xrightarrow[\bmod10^{10}]{\*26} 1605635584 \xrightarrow[\bmod10^{10}]{\*27} \dots~
Для ~N<5^{10}~, 10–12 цифр водночас і досить багато, щоб не втратити зразу всі ненульові цифри, і досить мало, щоб при черговому домноженні ніколи не виникало переповнення 64-бітового типу.

Спосіб № 2 отримати повні бали (крім Python).
Вже відзначено, що класична модульна арифметика (зберігати лише останню цифру) незастосовна, бо питають останню *ненульову*, й потрібний розряд час від часу зсувається. Але можна помітити, що раз кількість нулів наприкінці визначається кількістю п'ятірок, то, прибравши з ~N!~ відповідну кількість п'ятірок і таку саму кількість двійок, отримаємо якраз факторіал крім нулів наприкінці; для цього факторіала крім нулів наприкінці *можна* зберігати й обчислювати саму лише останню цифру.

Конкретніше, будемо при обчисленні ~1\times2\times\dots\times i\times\dots~ «виймати» з кожного числа всі множники 2 та 5, і рахувати окремо останню цифру добутку *всього, крім* «вийнятих» двійок та п'ятірок, окремо різницю кількостей «вийнятих» (на скільки двійок більше, ніж п'ятірок). Якось так:

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 0.
    *   Множимо на ~2=2^1\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на одну більше.
    *   **Новий стан:** остання цифра 1, надлишок двійок 1.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 1.
    *   Множимо на ~3=2^0\cdot5^0\cdot3~.
    *   **Коментар:** кількості двійок та п'ятірок незмінні, добуток решти домножується на 3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 1.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 1.
    *   Множимо на ~4=2^2\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на дві більше.
    *   **Новий стан:** остання цифра 3, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 3.
    *   Множимо на ~5=2^0\cdot5^1\cdot1~.
    *   **Коментар:** «зайвих» двійок стає на одну менше, бо одна двійка «зв'язується» п'ятіркою.
    *   **Новий стан:** остання цифра 3, надлишок двійок 2.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 2.
    *   Множимо на ~6=2^1\cdot5^0\cdot3~.
    *   **Коментар:** і двійок стає на одну більше, і добуток решти домножується на 3.
    *   **Новий стан:** остання цифра 9, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 9, надлишок двійок 3.
    *   Множимо на ~7=2^1\cdot5^0\cdot7~.
    *   **Коментар:** кількості двійок та п'ятірок незмінні, добуток решти домножується на 7, зберігаємо з 63 лише останню цифру 3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 3.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 3.
    *   Множимо на ~8=2^3\cdot5^0\cdot1~.
    *   **Коментар:** двійок стає на три більше.
    *   **Новий стан:** остання цифра 3, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 6.
    *   Множимо на ~9=2^0\cdot5^0\cdot9~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на ~10=2^1\cdot5^1\cdot1~.
    *   **Коментар:** додаються одна двійка й одна п'ятірка, *різниця* кількостей незмінна.
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на ~11=2^0\cdot5^0\cdot11~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 7, надлишок двійок 6.

*   **Початковий стан:** остання цифра добутку 7, надлишок двійок 6.
    *   Множимо на ~12=2^2\cdot5^0\cdot3~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 1, надлишок двійок 8.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 8.
    *   Множимо на ~13=2^0\cdot5^0\cdot13~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 3, надлишок двійок 8.

*   **Початковий стан:** остання цифра добутку 3, надлишок двійок 8.
    *   Множимо на ~14=2^1\cdot5^0\cdot7~.
    *   **Коментар:** (пусто).
    *   **Новий стан:** остання цифра 1, надлишок двійок 9.

*   **Початковий стан:** остання цифра добутку 1, надлишок двійок 9.
    *   Множимо на ~15=2^0\cdot5^1\cdot3~.
    *   **Коментар:** «зайвих» двійок стає на одну менше, бо одна двійка «зв'язується» п'ятіркою; крім того, добуток решти домножується на 3.
    *   **Новий стан:** остання цифра 3, надлишок двійок 8.

І так далі.
Дорахувавши до множника ~N~ (включно), знаємо останню цифру «~N!~ без двійок та п'ятірок» (позначимо як ~d~) та кількість «вільних» (не «зв'язаних» п'ятірками) двійок (позначимо як ~k~). Остаточна відповідь може бути виражена як ~ (d\cdot2^k)\bmod10 = (d\cdot(2^k\bmod10))\bmod10 ~. Враховуючи, що ~2^0=1~, ~2^1=2~, ~2^2=4~, ~2^3=8~, ~2^4=16~, ~2^5=32~, ~2^6=64~, ~2^7=128~, ~2^8=256~, ..., тобто при ~k>0~ останні цифри циклічно повторюються, велике ~k~ можна замінити на ~(k\bmod4)+4~, що дає можливість обчислювати ~2^k\bmod10~ за ~\Theta(1)~. Втім, це мало на що впливає, бо основний процес домножень (із «вийманням» з кожного числа двійок та п'ятірок) значно довший.

Який з цих способів кращий? Важко сказати. Вони обидва мають складність ~\Theta(N)~. (Може здатися, ніби для другого є ще внутрішні цикли «викидання» двійок і п'ятірок, які дають додатковий множник ~\log N~; але це не так. Наприклад, сумарну кількість ітерацій, які шукають двійки, можна виразити як ~N\mathrm{div}2+N\mathrm{div}2^2+\dots+N\mathrm{div}2^k~, де ~k=\lfloor\log_2 N\rfloor~; див. аргументацію формули (???) на стор. ???. Формула суми геометричної прогресії каже, що ця сума менша ~N~.)
При вказаних обмеженнях, обидва ці способи гарантовано проходять усі тести (всіма доступними на олімпіаді мовами програмування, *крім Python*; див. наступний абзац). Теоретичний недолік першого способу — якби дозволялися значення ~N>5^{11}\approx48,8~ млн, то 64-бітового типу вже було б недостатньо, щоб задовольнити обидві вимоги «не втратити зразу всі ненульові цифри» та «не утворювати переповнень»; другому ж способу цілком достатньо як 64-бітового, так і навіть 32-бітового типу аж до ~N\approx\frac{2^{31}}{9}\approx238~ млн (але при ~N\approx10^8~ обчислення вже тривали б десятки секунд).

Навіщо скривдили Python?
Він сам себе скривдив.
Програмам усіма мовами програмування виділявся однаковий ліміт часу. Але для розрахунків, вжитих в обох цих способах, Python виявився значно повільнішим не лише за традиційно швидкі мови `g++` та `fpc`, а також і за відносно повільні `java`, `pasabc-linux` та `mcs`. Враховуючи цю об'єктивну і значну різницю швидкодії, перед туром було прийняте свідоме рішення змиритися з тим, що реалізації одного алгоритму різними мовами набирають різні бали. З точки зору правил та традицій Всеукраїнської олімпіади з інформатики, це погано, але в такого роду виключних випадках допускається. До того ж, у цій самій задачі Python дозволяв отримати бали за тести вигляду ~25<N<555~, пишучи «лобовий» розв'язок і взагалі не замислюючись над тим, що така програма використовує довгу арифметику. Учасники, що вміють писати лише на Pascal чи C++, такої можливості не мали, і їм це ніяк не компенсувалося. Тож Python виграє в одному, програє в іншому, й навряд чи було б справедливішим надавати йому додаткові переваги, збільшуючи ліміт часу. Тим паче, що існує ще наступний спосіб.

Спосіб № 3 отримати повні бали (включно з Python).
Обмеження ~N<2018019~ підбиралося під те, щоб переважною більшістю мов працювали й набирали повний бал способи 1–2. Але задачу *можна* розв'язати ще значно ефективніше, якщо правильно модифікувати початий у способі № 2 підхід «двійки компенсують п'ятірки, для решти рахуємо останню цифру».
Вважаємо гарантованим ~N>10~, бо для ~N<10~ можна написати окремий `if`, щоб рахувати «в лоб».
Виділимо окремо множники, кратні 5, окремо решту, причому решту розіб'ємо на групи згідно десятків.
Наприклад, для 37! буде так: ~ (1\times2\times3\times4\times6\times7\times8\times9)\times(5\times10)\times(11\times12\times13\times14\times16\times17\times18\times19)\times(15\times20)\times(21\times22\times23\times24\times26\times27\times28\times29)\times(25\times30)\times(31\times32\times33\times34\times36\times37)\times(35) ~.
Добуток ~ (5\times10)\times(15\times20)\times(25\times30)\times(35) ~ можна подати як ~ ((5\cdot1)\times(5\cdot2))\times((5\cdot3)\times(5\cdot4))\times((5\cdot5)\times(5\cdot6))\times(5\cdot7) = 5^7\times7! ~.
(Важливо, що з кожного числа, кратного 5, виділяється рівно одна п'ятірка, навіть якщо, як з 25, їх можна було б виділити більше.) Так можна робити й при інших ~N~, отримуючи ~5^{N\mathrm{div}5}\times(N\mathrm{div}5)!~. Тобто, з початкової задачі для ~N!~ можна виділити таку саму задачу для ~(N\mathrm{div}5)!~, і при цьому решта множників поділені на більш-менш зручні групи по 8 з кожного десятку (в останній групі, й лише у ній, може бути менше).
Тож будемо окремо заново розв'язувати всю задачу для ~(N\mathrm{div}5)!~, і окремо компенсувати п'ятірки, зібрані в ~5^{N\mathrm{div}5}~, двійками з решти добутків.

Тобто, ~(N\mathrm{div}5)~ двійок треба «вийняти» з тих решти добутків. І міркувати «щоб вийняти множник з добутку, поділимо цей добуток на цей множник» тут не можна, бо в модульній арифметиці це часто не так. Наприклад, ~26\bmod10=6=56\bmod10~, тобто з точки зору остач за модулем 10 числа 26 та 56 однаковісінькі, але ~ \frac{26}{2}\bmod10=13\bmod10=3\neq8=28\bmod10=\frac{56}{2}\bmod10 ~.

Спробуємо компенсувати дві п'ятірки з ~(5\times10)~ двома двійками, «вийнятими» з ~(1\times2\times3\times4\times6\times7\times8\times9)~, дві п'ятірки з ~(15\times20)~ двома двійками з ~(11\times12\times13\times14\times16\times17\times18\times19)~, тощо. До того, що остання група може бути неповна, повернемося пізніше. Тим, що в кожних таких 8-множникових дужках можна знайти більше, ніж дві, двійки, знехтуємо: їх більше, але «вийматимемо» дві.

Візьмемо число, що закінчується цифрою 2, та число, що закінчується цифрою 4, й «виймемо» з кожного по одній двійці, поділивши кожне окремо на 2 (ділимо самі числа, не остачі). Можуть бути рівно два випадки: або ці числа являють собою ~20k+2~ та ~20k+4~, або ~20k+12~ та ~20k+14~; у першому випадку після ділень виходить ~10k+1~ та ~10k+2~, у другому ~10k+6~ та ~10k+7~. Оскільки в межах цих 8-множникових дужок більше не треба ділень, можна вертатися до модульної арифметики, відкидати ~10k~ і казати, що ~1\times2=2~ та ~6\times7=42~ закінчуються на однакову цифру 2.
Лишається домножити це 2 на останні цифри решти шести множників у дужках (1, 3, 6, 7, 8, 9), і отримати, що остання цифра добутку (після «виймання» двох двійок) дорівнює ~ (2\cdot1\cdot3\cdot6\cdot7\cdot8\cdot9)\bmod10 = 4 ~.
Остання цифра загального добутку всіх ~N\mathrm{div}10~ штук таких дужок рівна ~4^{N\mathrm{div}10}\bmod10~. Оскільки ~4^1=4~, ~4^2=16~, ~4^3=64~, ~4^4=256~, ..., а розглядаємо випадок ~N>10~, тобто ~(N\mathrm{div}10)>1~, значення ~4^{N\mathrm{div}10}\bmod10~ можна знайти якось у стилі `if ((N div 10) mod 2) = 1 then a:=4 else a:=6`.

Повернемось до врахування того, що при ~N\bmod10\neq0~ існує ще остання дужка, яка рахується не за тими правилами, що решта дужок. Якщо ~1<N\bmod10<4~, то цій дужці не треба компенсовувати ніяку п'ятірку, можна просто перемножити в модульній арифметиці останні цифри; інакше кажучи, ~(N\bmod10)!\bmod10~. Якщо ж ~5<N\bmod10<9~, то треба компенсувати рівно одну п'ятірку. (Навіть якщо число останнього неповного десятку, що закінчується на 5, кратне деякому ~5^k~ при більшому ~k~, то всі п'ятірки, крім однієї, перейшли у ~(N\mathrm{div}5)!~.) Поділимо на 2 число, що закінчується цифрою 2; можливі рівно два випадки: або воно вигляду ~20k+2~, або ~20k+12~; у першому отримуємо ~10k+1~, у другому ~10k+6~; більше ділень не треба, можна вертатися до модульної арифметики. Точно треба домножити на 3 та 4 (бо розглядаємо випадок ~5<N\bmod10<9~); отримуємо або ~(1\times3\times4)\bmod10=12\bmod10=2~, або ~(6\times3\times4)\bmod10=72\bmod10=2~, тобто в обох випадках 2. Множити на 5 не треба й не можна, ця п'ятірка вже врахована іншими засобами.
Лишається тільки домножити в модульній арифметиці на 6, 7, ..., ~N\bmod10~ (зокрема, при ~N\bmod10=5~, не домножувати ні на що).

Дії попереднього абзацу насправді рівносильні таким: «порахувати "в лоб" ~(N\bmod10)!~; якщо кратний 10, поділити на 10; взяти останню цифру». Це навіть простіше писати. Але неясно, як строго доводити правильність цього, не спираючись на попередній абзац.

Само собою, треба помножити (в модульній арифметиці) результат (поза)минулого абзаца на раніше отриманий (рівний або 4, або 6) результат ~4^{N\mathrm{div}10}\bmod10~, а також домножити (в модульній арифметиці) цей добуток на ~(N\mathrm{div}5)!\bmod10~, розв'язавши всю задачу заново з аргументом ~N\mathrm{div}5~ замість ~N~. Це повторюватиметься приблизно ~\log_5 N~ разів. Що й задає асимптотичну оцінку всього розв'язку ~\Theta(\log N)~, бо все інше виконується за ~\Theta(1)~ (щось `if`-ом, щось циклом, але з дуже малою кількістю ітерацій). Так що задачу в принципі можна було давати і для значно більших ~N~. Втім, вона і з обмеженням ~N<2018019~ виявилася дещо заскладною для переважної більшості учасників.﻿
